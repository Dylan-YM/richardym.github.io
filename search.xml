<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[更新Xcode8的坑]]></title>
      <url>http://yoursite.com/blog/2016/09/15/Xcode8.html</url>
      <content type="html"><![CDATA[<p>现在在苹果的官网上，我们已经可以下载到Xcode8的GM版本了，加上9.14日凌晨，苹果就要正式推出iOS10系统的推送了，在此之际，iOS10的适配已经迫在眉睫啦，不知道Xcode8 beat版本，童鞋们有木有下载过来试试呢？就我的使用来说，总体觉得苹果还是坑不断，但是也在一直进步的啦。下面我就来说说，iOS10的适配以及Xcode8使用上的一些注意点。</p>
<h2 id="Notification-通知"><a href="#Notification-通知" class="headerlink" title="Notification(通知)"></a>Notification(通知)</h2><p>自从Notification被引入之后，苹果就不断的更新优化，但这些更新优化只是小打小闹，直至现在iOS 10开始真正的进行大改重构，这让开发者也体会到UserNotifications的易用，功能也变得非常强大。</p>
<ul>
<li>iOS 9 以前的通知</li>
</ul>
<p>1.在调用方法时，有些方法让人很难区分，容易写错方法，这让开发者有时候很苦恼。</p>
<p>2.应用在运行时和非运行时捕获通知的路径还不一致。</p>
<p>3.应用在前台时，是无法直接显示远程通知，还需要进一步处理。</p>
<p>4.已经发出的通知是不能更新的，内容发出时是不能改变的，并且只有简单文本展示方式，扩展性根本不是很好。</p>
<ul>
<li>iOS 10 开始的通知</li>
</ul>
<p>1.所有相关通知被统一到了UserNotifications.framework框架中。</p>
<p>2.增加了撤销、更新、中途还可以修改通知的内容。</p>
<p>3.通知不在是简单的文本了，可以加入视频、图片，自定义通知的展示等等。</p>
<p>4.iOS 10相对之前的通知来说更加好用易于管理，并且进行了大规模优化，对于开发者来说是一件好事。</p>
<p>5.iOS 10开始对于权限问题进行了优化，申请权限就比较简单了(本地与远程通知集成在一个方法中)。</p>
<h2 id="ATS的问题"><a href="#ATS的问题" class="headerlink" title="ATS的问题"></a>ATS的问题</h2><p>iOS 9中默认非HTTS的网络是被禁止的，当然我们也可以把NSAllowsArbitraryLoads设置为YES禁用ATS。不过iOS 10从2017年1月1日起苹果不允许我们通过这个方法跳过ATS，也就是说强制我们用HTTPS，如果不这样的话提交App可能会被拒绝。但是我们可以通过NSExceptionDomains来针对特定的域名开放HTTP可以容易通过审核。</p>
<p>NSExceptionDomains方式 设置域。可以简单理解成，把不支持https协议的接口设置成http的接口。</p>
<p>具体方法：</p>
<p>1.在项目的info.plist中添加一个Key：App Transport Security Settings，类型为字典类型。</p>
<p>2.然后给它添加一个Exception Domains，类型为字典类型；</p>
<p>3.把需要的支持的域添加給Exception Domains。其中域作为Key，类型为字典类型。</p>
<p>4.每个域下面需要设置3个属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSIncludesSubdomains</div><div class="line">NSExceptionRequiresForwardSecrecy</div><div class="line">NSExceptionAllowsInsecureHTTPLoads</div></pre></td></tr></table></figure>
<p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918170238256-1807962290.png" alt=""></p>
<p>细节提示:在iOS9以后的系统中如果使用到网络图片，也要注意网络图片是否是HTTP的哦，如果是，也要把图片的域设置哦！</p>
<h2 id="iOS-10-隐私权限设置"><a href="#iOS-10-隐私权限设置" class="headerlink" title="iOS 10 隐私权限设置"></a>iOS 10 隐私权限设置</h2><p>iOS 10 开始对隐私权限更加严格，如果你不设置就会直接崩溃，现在很多遇到崩溃问题了，一般解决办法都是在info.plist文件添加对应的Key-Value就可以了。</p>
<p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918164446868-505879984.png" alt=""></p>
<p>以上Value值，圈出的红线部分的文字是展示给用户看的，必须添加。</p>
<h2 id="Xcode-8-运行一堆没用的logs解决办法"><a href="#Xcode-8-运行一堆没用的logs解决办法" class="headerlink" title="Xcode 8 运行一堆没用的logs解决办法"></a>Xcode 8 运行一堆没用的logs解决办法</h2><p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114127228-2093692903.jpg" alt=""><br>上图我们看到，自己新建的一个工程啥也没干就打印一堆烂七八糟的东西，我觉得这个应该是Xcode 8的问题，</p>
<p>具体也没细研究，解决办法是设置OS_ACTIVITY_MODE : disable如下图:<br><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114153542-1346537228.jpg" alt=""></p>
<h2 id="iOS-10-UIStatusBar方法过期"><a href="#iOS-10-UIStatusBar方法过期" class="headerlink" title="iOS 10 UIStatusBar方法过期:"></a>iOS 10 UIStatusBar方法过期:</h2><p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114216825-2072979176.jpg" alt=""></p>
<p>在我们开发中有可能用到UIStatusBar一些属性，在iOS 10 中这些方法已经过期了，如果你的项目中有用的话就得需要适配。</p>
<p>上面的图片也能发现，如果在iOS 10中你需要使用preferredStatusBar比如这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">UIStatusBarStyle</span>)preferredStatusBarStyle &#123; </div><div class="line">   <span class="keyword">return</span> <span class="built_in">UIStatusBarStyleDefault</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="iOS-10-UICollectionView-性能优化"><a href="#iOS-10-UICollectionView-性能优化" class="headerlink" title="iOS 10 UICollectionView 性能优化"></a>iOS 10 UICollectionView 性能优化</h2><p>随着开发者对UICollectionView的信赖，项目中用的地方也比较多，但是还是存在一些问题，比如有时会卡顿、加载慢等。所以iOS 10 对UICollectionView进一步的优化。</p>
<ul>
<li>UICollectionView cell pre-fetching预加载机制</li>
<li>UICollectionView and UITableView prefetchDataSource    新增的API 针对self-sizing cells 的改进</li>
<li>Interactive reordering</li>
</ul>
<p>在iOS 10 之前,UICollectionView上面如果有大量cell,当用户活动很快的时候,整个UICollectionView的卡顿会很明显,为什么会造成这样的问题,这里涉及到了iOS 系统的重用机制,当cell准备加载进屏幕的时候,整个cell都已经加载完成,等待在屏幕外面了,也就是整整一行cell都已经加载完毕,这就是造成卡顿的主要原因,专业术语叫做:掉帧.<br>要想让用户感觉不到卡顿,我们的app必须帧率达到60帧/秒,也就是说每帧16毫秒要刷新一次.</p>
<p>iOS 10 之前UICollectionViewCell的生命周期是这样的:</p>
<ul>
<li>1.用户滑动屏幕,屏幕外有一个cell准备加载进来,把cell从reusr队列拿出来,然后调用prepareForReuse方法,在这个方法里面,可以重置cell的状态,加载新的数据;</li>
<li>2.继续滑动,就会调用cellForItemAtIndexPath方法,在这个方法里面给cell赋值模型,然后返回给系统;</li>
<li>3.当cell马上进去屏幕的时候,就会调用willDisplayCell方法,在这个方法里面我们还可以修改cell,为进入屏幕做最后的准备工作;</li>
<li>4.执行完willDisplayCell方法后,cell就进去屏幕了.当cell完全离开屏幕以后,会调用didEndDisplayingCell方法.</li>
</ul>
<p>　iOS 10 UICollectionViewCell的生命周期是这样的:</p>
<ul>
<li>1.用户滑动屏幕,屏幕外有一个cell准备加载进来,把cell从reusr队列拿出来,然后调用prepareForReuse方法,在这里当cell还没有进去屏幕的时候,就已经提前调用这个方法了,对比之前的区别是之前是cell的上边缘马上进去屏幕的时候就会调用该方法,而iOS 10 提前到cell还在屏幕外面的时候就调用;</li>
<li>2.在cellForItemAtIndexPath中创建cell，填充数据，刷新状态等操作,相比于之前也提前了;</li>
<li>3.用户继续滑动的话,当cell马上就需要显示的时候我们再调用willDisplayCell方法,原则就是:何时需要显示,何时再去调用willDisplayCell方法;</li>
<li>4.当cell完全离开屏幕以后,会调用didEndDisplayingCell方法,跟之前一样,cell会进入重用队列.</li>
<li>在iOS 10 之前,cell只能从重用队列里面取出,再走一遍生命周期,并调用cellForItemAtIndexPath创建或者生成一个cell.<br>在iOS 10 中,系统会cell保存一段时间,也就是说当用户把cell滑出屏幕以后,如果又滑动回来,cell不用再走一遍生命周期了,只需要调用willDisplayCell方法就可以重新出现在屏幕中了.</li>
<li>iOS 10 中,系统是一个一个加载cell的,二以前是一行一行加载的,这样就可以提升很多性能;</li>
<li>iOS 10 新增加的Pre-Fetching预加载 </li>
<li>这个是为了降低UICollectionViewCell在加载的时候所花费的时间,在 iOS 10 中,除了数据源协议和代理协议外,新增加了一个UICollectionViewDataSourcePrefetching协议,这个协议里面定义了两个方法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView prefetchItemsAtIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cancelPrefetchingForItemsAtIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths  <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div></pre></td></tr></table></figure>
<p>　　　在ColletionView prefetchItemsAt indexPaths这个方法是异步预加载数据的,当中的indexPaths数组是有序的,就是item接收数据的顺序;<br>　　　CollectionView cancelPrefetcingForItemsAt indexPaths这个方法是可选的,可以用来处理在滑动中取消或者降低提前加载数据的优先级.<br>　　　注意:这个协议并不能代替之前读取数据的方法,仅仅是辅助加载数据.<br>　　　Pre-Fetching预加载对UITableViewCell同样适用.
　　　</p>
<h2 id="iOS-10-UIColor-新增方法"><a href="#iOS-10-UIColor-新增方法" class="headerlink" title="iOS 10 UIColor 新增方法"></a>iOS 10 UIColor 新增方法</h2><p>以下是官方文档的说明：</p>
<p>Most graphics frameworks throughout the system, including Core Graphics, Core Image, Metal, and AVFoundation, have substantially improved support for extended-range pixel formats and wide-gamut color spaces. By extending this behavior throughout the entire graphics stack, it is easier than ever to support devices with a wide color display. In addition, UIKit standardizes on working in a new extended sRGB color space, making it easy to mix sRGB colors with colors in other, wider color gamuts without a significant performance penalty.</p>
<p>Here are some best practices to adopt as you start working with Wide Color.</p>
<ul>
<li>In iOS 10, the UIColor class uses the extended sRGB color space and its initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10.</li>
<li>When performing custom drawing in a UIView on an iPad Pro (9.7 inch), the underlying drawing environment is configured with an extended sRGB color space.</li>
<li>If your app renders custom image objects, use the new UIGraphicsImageRenderer class to control whether the destination bitmap is created using an extended-range or standard-range format.</li>
<li>If you are performing your own image processing on wide-gamut devices using a lower level API, such as Core Graphics or Metal, you should use an extended range color space and a pixel format that supports 16-bit floating-point component values. When clamping of color values is necessary, you should do so explicitly.</li>
<li><p>Core Graphics, Core Image, and Metal Performance Shaders provide new options for easily converting colors and images between color spaces.</p>
<p>因为之前我们都是用RGB来设置颜色，反正用起来也不是特别多样化，这次新增的方法应该就是一个弥补吧。所以在iOS 10 苹果官方建议我们使用sRGB，因为它性能更好，色彩更丰富。如果你自己为UIColor写了一套分类的话也可尝试替换为sRGB，UIColor类中新增了两个Api如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIColor</span> *)colorWithDisplayP3Red:(<span class="built_in">CGFloat</span>)displayP3Red green:(<span class="built_in">CGFloat</span>)green blue:(<span class="built_in">CGFloat</span>)blue alpha:(<span class="built_in">CGFloat</span>)alpha <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line">- (<span class="built_in">UIColor</span> *)initWithDisplayP3Red:(<span class="built_in">CGFloat</span>)displayP3Red green:(<span class="built_in">CGFloat</span>)green blue:(<span class="built_in">CGFloat</span>)blue alpha:(<span class="built_in">CGFloat</span>)alpha <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="iOS-10-UITextContentType"><a href="#iOS-10-UITextContentType" class="headerlink" title="iOS 10 UITextContentType"></a>iOS 10 UITextContentType</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// The textContentType property is to provide the keyboard with extra information about the semantic intent of the text document.@property(nonatomic,copy) UITextContentType textContentType NS_AVAILABLE_IOS(10_0); // default is nil</div></pre></td></tr></table></figure>
<p>在iOS 10 UITextField添加了textContentType枚举，指示文本输入区域所期望的语义意义。</p>
<p>使用此属性可以给键盘和系统信息，关于用户输入的内容的预期的语义意义。例如，您可以指定一个文本字段，用户填写收到一封电子邮件确认uitextcontenttypeemailaddress。当您提供有关您期望用户在文本输入区域中输入的内容的信息时，系统可以在某些情况下自动选择适当的键盘，并提高键盘修正和主动与其他文本输入机会的整合。 </p>
<h2 id="iOS-10-字体随着手机系统字体而改变"><a href="#iOS-10-字体随着手机系统字体而改变" class="headerlink" title="iOS 10 字体随着手机系统字体而改变"></a>iOS 10 字体随着手机系统字体而改变</h2><p>当我们手机系统字体改变了之后，那我们App的label也会跟着一起变化，这需要我们写很多代码来进一步处理才能实现，但是iOS 10 提供了这样的属性adjustsFontForContentSizeCategory来设置。因为没有真机，具体实际操作还没去实现，如果理解错误帮忙指正。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UILabel *myLabel = [UILabel new];   /*</div><div class="line">   UIFont 的preferredFontForTextStyle: 意思是指定一个样式，并让字体大小符合用户设定的字体大小。</div><div class="line">  */</div><div class="line">   myLabel.font =[UIFont preferredFontForTextStyle: UIFontTextStyleHeadline]; /*</div><div class="line">Indicates whether the corresponding element should automatically update its font when the device’s UIContentSizeCategory is changed.</div><div class="line">For this property to take effect, the element’s font must be a font vended using +preferredFontForTextStyle: or +preferredFontForTextStyle:compatibleWithTraitCollection: with a valid UIFontTextStyle.</div><div class="line">*/</div><div class="line">    //是否更新字体的变化</div><div class="line">   myLabel.adjustsFontForContentSizeCategory = YES;</div></pre></td></tr></table></figure>
<h2 id="iOS-10-UIScrollView新增refreshControl"><a href="#iOS-10-UIScrollView新增refreshControl" class="headerlink" title="iOS 10 UIScrollView新增refreshControl"></a>iOS 10 UIScrollView新增refreshControl</h2><p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114540839-1874104118.png" alt=""></p>
<p>iOS 10 以后只要是继承UIScrollView那么就支持刷新功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">UIRefreshControl</span> *refreshControl <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<h2 id="iOS-10-判断系统版本正确姿势"><a href="#iOS-10-判断系统版本正确姿势" class="headerlink" title="iOS 10 判断系统版本正确姿势"></a>iOS 10 判断系统版本正确姿势</h2><p>判断系统版本是我们经常用到的，尤其是现在大家都有可能需要适配iOS 10，那么问题就出现了，如下图：<br><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114620576-1303627103.jpg" alt=""></p>
<p>我们得到了答案是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//值为 1 [[[[UIDevice currentDevice] systemVersion] substringToIndex:1] <span class="built_in">integer</span>Value]</div><div class="line"></div><div class="line">//值为10.000000 [[UIDevice currentDevice] systemVersion].floatValue,</div><div class="line"></div><div class="line">//值为10.0 [[UIDevice currentDevice] systemVersion]</div></pre></td></tr></table></figure>
<p>所以说判断系统方法最好还是用后面的两种方法，哦~我忘记说了[[UIDevice currentDevice] systemVersion].floatValue这个方法也是不靠谱的，好像在8.3版本输出的值是8.2，记不清楚了反正是不靠谱的，所以建议大家用[[UIDevice<br> currentDevice] systemVersion]这个方法！</p>
<p> Swift判断如下：</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</div><div class="line">         <span class="comment">// iOS 10.0</span></div><div class="line">         <span class="built_in">print</span>(<span class="string">"iOS 10.0"</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="Xcode-8-插件不能用的问题"><a href="#Xcode-8-插件不能用的问题" class="headerlink" title="Xcode 8 插件不能用的问题"></a>Xcode 8 插件不能用的问题</h2><p>大家都升级了Xcode 8，但是对于插件依赖的开发者们，一边哭着一边去网上寻找解决办法。那么下面是解决办法：<br>让你的 Xcode8 继续使用插件(<a href="http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/?utm_source=tuicool&amp;utm_medium=referral</a> )</p>
<p>但是看到文章最后的解释，我们知道如果用插件的话，可能安全上会有问题、并且提交审核会被拒绝，所以建议大家还是不要用了，解决办法总是有的，比如在Xcode中添加注释的代码块也是很方便的。</p>
<h2 id="iOS-10开始项目中有的文字显示不全问题"><a href="#iOS-10开始项目中有的文字显示不全问题" class="headerlink" title="iOS 10开始项目中有的文字显示不全问题"></a>iOS 10开始项目中有的文字显示不全问题</h2><p>我用Xcode 8 和Xcode 7.3分别测试了下，如下图：</p>
<p>xcode7<br><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114911979-1889192985.jpg" alt="xcode7"><br>xcode8</p>
<p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918114920417-1828331146.jpg" alt="xcode8"></p>
<p>创建一个Label然后让它自适应大小，字体大小都是17最后输出的宽度是不一样的，我们再看一下，<br>下面的数据就知道为什么升级iOS 10 之后App中有的文字显示不全了：</p>
<p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918115047642-1072358093.png" alt=""></p>
<p>英文字母会不会也有这种问题，我又通过测试，后来发现英文字母没有问题，只有汉字有问题。<br>目前只有一个一个修改控件解决这个问题，暂时没有其他好办法来解决。</p>
<h2 id="Xcode-8使用Xib-awakeFromNib的警告问题"><a href="#Xcode-8使用Xib-awakeFromNib的警告问题" class="headerlink" title="Xcode 8使用Xib awakeFromNib的警告问题"></a>Xcode 8使用Xib awakeFromNib的警告问题</h2><p>在Xcode 8之前我们使用Xib初始化- (void)awakeFromNib {}都是这么写也没什么问题，但是在Xcode 8会有如下警告：</p>
<p><img src="http://images2015.cnblogs.com/blog/575661/201609/575661-20160918164934170-318856946.png" alt=""></p>
<p>官方解释：<br>You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require.<br>Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations.<br>You may call the super implementation at any point during your own awakeFromNib method.</p>
<p>你必须调用父类实现awakeFromNib来给父类来执行它们需要的任何额外的初始化的机会。<br>虽然这种方法的默认实现不做任何事情，许多UIKit类提供非空的实现。<br>你可以调用自己的awakeFromNib方法中的任何时候超级实现</p>
<p>　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[苹果Mac os系统u盘安装系统制作教程]]></title>
      <url>http://yoursite.com/blog/2016/08/15/MacOSCreat.html</url>
      <content type="html"><![CDATA[<h3 id="苹果系统Mac-OS-X安装U盘怎么制作-很多苹果的用户都不知道如何使用U盘装系统，而苹果Mac电脑通过U盘安装系统-前提的是需要先制作Mac启动U盘，许多果粉在删除或者需要重装苹果系统的时候，都不知道应该要如何使用U盘制作工具来安装苹果系统，本文主要为大家介绍苹果系统U盘制作教程。"><a href="#苹果系统Mac-OS-X安装U盘怎么制作-很多苹果的用户都不知道如何使用U盘装系统，而苹果Mac电脑通过U盘安装系统-前提的是需要先制作Mac启动U盘，许多果粉在删除或者需要重装苹果系统的时候，都不知道应该要如何使用U盘制作工具来安装苹果系统，本文主要为大家介绍苹果系统U盘制作教程。" class="headerlink" title="　　苹果系统Mac OS X安装U盘怎么制作?很多苹果的用户都不知道如何使用U盘装系统，而苹果Mac电脑通过U盘安装系统,前提的是需要先制作Mac启动U盘，许多果粉在删除或者需要重装苹果系统的时候，都不知道应该要如何使用U盘制作工具来安装苹果系统，本文主要为大家介绍苹果系统U盘制作教程。"></a>　　苹果系统Mac OS X安装U盘怎么制作?很多苹果的用户都不知道如何使用U盘装系统，而苹果Mac电脑通过U盘安装系统,前提的是需要先制作Mac启动U盘，许多果粉在删除或者需要重装苹果系统的时候，都不知道应该要如何使用U盘制作工具来安装苹果系统，本文主要为大家介绍苹果系统U盘制作教程。</h3><a id="more"></a>
<h4 id="一：提前准备：8G空U盘、OS-X-10-11安装文件。"><a href="#一：提前准备：8G空U盘、OS-X-10-11安装文件。" class="headerlink" title="一：提前准备：8G空U盘、OS X 10.11安装文件。"></a>一：提前准备：8G空U盘、OS X 10.11安装文件。</h4><h4 id="二：首先准备一个空的U盘-最低8GB的-，如果里面有重要资料请及时拷贝出来。"><a href="#二：首先准备一个空的U盘-最低8GB的-，如果里面有重要资料请及时拷贝出来。" class="headerlink" title="二：首先准备一个空的U盘(最低8GB的)，如果里面有重要资料请及时拷贝出来。"></a>二：首先准备一个空的U盘(最低8GB的)，如果里面有重要资料请及时拷贝出来。</h4><h4 id="三：进入Finder-应用程序-实用工具，运行里面的“磁盘工具”软件，或者直接用-Spotlight-搜索“磁盘工具”-打开。"><a href="#三：进入Finder-应用程序-实用工具，运行里面的“磁盘工具”软件，或者直接用-Spotlight-搜索“磁盘工具”-打开。" class="headerlink" title="三：进入Finder-应用程序-实用工具，运行里面的“磁盘工具”软件，或者直接用 Spotlight 搜索“磁盘工具” 打开。"></a>三：进入Finder-应用程序-实用工具，运行里面的“磁盘工具”软件，或者直接用 Spotlight 搜索“磁盘工具” 打开。</h4><p><img src="http://img.mp.itc.cn/upload/20160622/1280301bf6de43c59538ef8fc7fce58a_th.jpg" alt="磁盘工具"></p>
<h4 id="四：在左方列表中找到U盘的名称并点击，顶部选择「抹掉」，然后在此界面中将格式更改为Mac-OS扩展-日志式-名称命名为MyVolume。"><a href="#四：在左方列表中找到U盘的名称并点击，顶部选择「抹掉」，然后在此界面中将格式更改为Mac-OS扩展-日志式-名称命名为MyVolume。" class="headerlink" title="四：在左方列表中找到U盘的名称并点击，顶部选择「抹掉」，然后在此界面中将格式更改为Mac OS扩展(日志式)名称命名为MyVolume。"></a>四：在左方列表中找到U盘的名称并点击，顶部选择「抹掉」，然后在此界面中将格式更改为Mac OS扩展(日志式)名称命名为MyVolume。</h4><p><img src="http://img.mp.itc.cn/upload/20160622/9067b084af1a467a96560b1ac22282da_th.jpg" alt=""></p>
<h4 id="五：点「抹掉」开始对U盘进行格式化。"><a href="#五：点「抹掉」开始对U盘进行格式化。" class="headerlink" title="五：点「抹掉」开始对U盘进行格式化。"></a>五：点「抹掉」开始对U盘进行格式化。</h4><h4 id="六：OS-X-10-11安装文件“安装OS-X-EL-Capitan”放置在Finder-应用程序下。"><a href="#六：OS-X-10-11安装文件“安装OS-X-EL-Capitan”放置在Finder-应用程序下。" class="headerlink" title="六：OS X 10.11安装文件“安装OS X EL Capitan”放置在Finder-应用程序下。"></a>六：OS X 10.11安装文件“安装OS X EL Capitan”放置在Finder-应用程序下。</h4><p><img src="http://img.mp.itc.cn/upload/20160622/710420907e66492ab3bce71422f1330d_th.jpg" alt=""></p>
<h4 id="七：打开Finder-应用程序-实用工具-终端。"><a href="#七：打开Finder-应用程序-实用工具-终端。" class="headerlink" title="七：打开Finder-应用程序-实用工具-终端。"></a>七：打开Finder-应用程序-实用工具-终端。</h4><p><img src="http://img.mp.itc.cn/upload/20160622/605df88e325b447db6c2f2b20da09fec_th.jpg" alt=""></p>
<h4 id="八：双击终端之后会出现一个类似文本文档的框框，复制下方代码后回车-苹果电脑复制黏贴快捷键-复制键：Command-C-粘贴键：Command-V"><a href="#八：双击终端之后会出现一个类似文本文档的框框，复制下方代码后回车-苹果电脑复制黏贴快捷键-复制键：Command-C-粘贴键：Command-V" class="headerlink" title="八：双击终端之后会出现一个类似文本文档的框框，复制下方代码后回车;苹果电脑复制黏贴快捷键(复制键：Command+C;粘贴键：Command+V)"></a>八：双击终端之后会出现一个类似文本文档的框框，复制下方代码后回车;苹果电脑复制黏贴快捷键(复制键：Command+C;粘贴键：Command+V)</h4><p><img src="http://img.mp.itc.cn/upload/20160622/05219943e9014343aef7787f76f2fe38_th.jpg" alt=""></p>
<h4 id="九："><a href="#九：" class="headerlink" title="九："></a>九：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app</div></pre></td></tr></table></figure>
<h4 id="十：password：处输入开机密码，但是密码不会显示出来，输入完“回车”。"><a href="#十：password：处输入开机密码，但是密码不会显示出来，输入完“回车”。" class="headerlink" title="十：password：处输入开机密码，但是密码不会显示出来，输入完“回车”。"></a>十：password：处输入开机密码，但是密码不会显示出来，输入完“回车”。</h4><p><img src="http://img.mp.itc.cn/upload/20160622/0c8d287c7f5747a492b279b96bac5a3e_th.jpg" alt=""></p>
<h4 id="十一：选择“Y”，“回车”"><a href="#十一：选择“Y”，“回车”" class="headerlink" title="十一：选择“Y”，“回车”"></a>十一：选择“Y”，“回车”</h4><p><img src="http://img.mp.itc.cn/upload/20160622/b1d5f8b10c35483aa354ec53aa1afd70_th.jpg" alt=""></p>
<h3 id="以下终端显示内容："><a href="#以下终端显示内容：" class="headerlink" title="以下终端显示内容："></a>以下终端显示内容：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Erasing Disk: 0%;... 10%;... 20%;... 30%;...100%;...</div><div class="line">　　Copying installer files to disk...</div><div class="line">　　Copy complete.</div><div class="line">　　Making disk bootable...</div><div class="line">　　Copying boot files...</div><div class="line">　　Copy complete.</div><div class="line">　　Done.</div></pre></td></tr></table></figure>
<h3 id="done出现后，表示制作完成，大概时间30分钟左右，可能部分机型时间稍长。"><a href="#done出现后，表示制作完成，大概时间30分钟左右，可能部分机型时间稍长。" class="headerlink" title="　done出现后，表示制作完成，大概时间30分钟左右，可能部分机型时间稍长。"></a>　done出现后，表示制作完成，大概时间30分钟左右，可能部分机型时间稍长。</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift - 按钮（UIButton）的用法]]></title>
      <url>http://yoursite.com/blog/2016/06/20/swift-UIButton.html</url>
      <content type="html"><![CDATA[<h4 id="1-按钮有下面四种类型："><a href="#1-按钮有下面四种类型：" class="headerlink" title="1. 按钮有下面四种类型："></a>1. 按钮有下面四种类型：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UIButtonType.ContactAdd：前面带“+”图标按钮，默认文字颜色为蓝色，有触摸时的高亮效果</div><div class="line">UIButtonType.DetailDisclosure：前面带“!”图标按钮，默认文字颜色为蓝色，有触摸时的高亮效果</div><div class="line">UIButtonType.System：前面不带图标，默认文字颜色为蓝色，有触摸时的高亮效果</div><div class="line">UIButtonType.Custom：定制按钮，前面不带图标，默认文字颜色为白色，无触摸时的高亮效果</div><div class="line">UIButtonType.InfoDark：为感叹号“!”圆形按钮</div><div class="line">UIButtonType.InfoLight：为感叹号“!”圆形按钮</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个ContactAdd类型的按钮</span></div><div class="line"><span class="keyword">let</span> button:<span class="type">UIButton</span> = <span class="type">UIButton</span>(type:.<span class="type">ContactAdd</span>)</div><div class="line"><span class="comment">//设置按钮位置和大小</span></div><div class="line">button.frame=<span class="type">CGRectMake</span>(<span class="number">10</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">30</span>)</div><div class="line"><span class="comment">//设置按钮文字</span></div><div class="line">button.setTitle(<span class="string">"按钮"</span>, forState:<span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line"><span class="keyword">self</span>.view.addSubview(button);</div></pre></td></tr></table></figure>
<h4 id="2-对于Custom定制类型按钮，代码可简化为："><a href="#2-对于Custom定制类型按钮，代码可简化为：" class="headerlink" title="2.对于Custom定制类型按钮，代码可简化为："></a>2.对于Custom定制类型按钮，代码可简化为：</h4><a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(frame:<span class="type">CGRectMake</span>(<span class="number">10</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">30</span>))</div></pre></td></tr></table></figure>
<h4 id="3-按钮的文字设置"><a href="#3-按钮的文字设置" class="headerlink" title="3.按钮的文字设置"></a>3.按钮的文字设置</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.setTitle(<span class="string">"普通状态"</span>, forState:<span class="type">UIControlState</span>.<span class="type">Normal</span>) <span class="comment">//普通状态下的文字</span></div><div class="line">button.setTitle(<span class="string">"触摸状态"</span>, forState:<span class="type">UIControlState</span>.<span class="type">Highlighted</span>) <span class="comment">//触摸状态下的文字</span></div><div class="line">button.setTitle(<span class="string">"禁用状态"</span>, forState:<span class="type">UIControlState</span>.<span class="type">Disabled</span>) <span class="comment">//禁用状态下的文字</span></div></pre></td></tr></table></figure>
<h4 id="4-按钮文字颜色的设置"><a href="#4-按钮文字颜色的设置" class="headerlink" title="4.按钮文字颜色的设置"></a>4.按钮文字颜色的设置</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.setTitleColor(<span class="type">UIColor</span>.blackColor(),forState: .<span class="type">Normal</span>) <span class="comment">//普通状态下文字的颜色</span></div><div class="line">button.setTitleColor(<span class="type">UIColor</span>.greenColor(),forState: .<span class="type">Highlighted</span>) <span class="comment">//触摸状态下文字的颜色</span></div><div class="line">button.setTitleColor(<span class="type">UIColor</span>.grayColor(),forState: .<span class="type">Disabled</span>) <span class="comment">//禁用状态下文字的颜色</span></div></pre></td></tr></table></figure>
<h4 id="5-按钮文字阴影颜色的设置"><a href="#5-按钮文字阴影颜色的设置" class="headerlink" title="5.按钮文字阴影颜色的设置"></a>5.按钮文字阴影颜色的设置</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.setTitleShadowColor(<span class="type">UIColor</span>.greenColor(),forState:.<span class="type">Normal</span>) <span class="comment">//普通状态下文字阴影的颜色</span></div><div class="line">button.setTitleShadowColor(<span class="type">UIColor</span>.yellowColor(),forState:.<span class="type">Highlighted</span>) <span class="comment">//普通状态下文字阴影的颜色</span></div><div class="line">button.setTitleShadowColor(<span class="type">UIColor</span>.grayColor(),forState:.<span class="type">Disabled</span>) <span class="comment">//普通状态下文字阴影的颜色</span></div></pre></td></tr></table></figure>
<h4 id="6-按钮背景颜色设置"><a href="#6-按钮背景颜色设置" class="headerlink" title="6. 按钮背景颜色设置"></a>6. 按钮背景颜色设置</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.backgroundColor=<span class="type">UIColor</span>.blackColor()</div></pre></td></tr></table></figure>
<h4 id="7-按钮文字图标的设置"><a href="#7-按钮文字图标的设置" class="headerlink" title="7.按钮文字图标的设置"></a>7.按钮文字图标的设置</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.setImage(<span class="type">UIImage</span>(named:<span class="string">"icon1"</span>),forState:.<span class="type">Normal</span>)  <span class="comment">//设置图标</span></div><div class="line">button.adjustsImageWhenHighlighted=<span class="literal">false</span> <span class="comment">//使触摸模式下按钮也不会变暗</span></div><div class="line">button.adjustsImageWhenDisabled=<span class="literal">false</span> <span class="comment">//使禁用模式下按钮也不会变暗</span></div></pre></td></tr></table></figure>
<h4 id="8-设置按钮背景图片"><a href="#8-设置按钮背景图片" class="headerlink" title="8.设置按钮背景图片"></a>8.设置按钮背景图片</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setBackgroundImage(<span class="type">UIImage</span>(named:<span class="string">"background1"</span>),forState:.<span class="type">Normal</span>)</div></pre></td></tr></table></figure>
<h4 id="9-按钮触摸点击事件响应"><a href="#9-按钮触摸点击事件响应" class="headerlink" title="9.按钮触摸点击事件响应"></a>9.按钮触摸点击事件响应</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不传递触摸对象（即点击的按钮）</span></div><div class="line">button.addTarget(<span class="keyword">self</span>,action:#selector(tapped),forControlEvents:.<span class="type">TouchUpInside</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tapped</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"tapped"</span>)</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//传递触摸对象（即点击的按钮），需要在定义action参数时，方法名称后面带上冒号</span></div><div class="line">button.addTarget(<span class="keyword">self</span>,action:#selector(tapped(<span class="number">_</span>:)),forControlEvents:.<span class="type">TouchUpInside</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tapped</span><span class="params">(button:UIButton)</span></span>&#123;</div><div class="line">    <span class="built_in">print</span>(button.titleForState(.<span class="type">Normal</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的触摸事件类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TouchDown：单点触摸按下事件，点触屏幕</div><div class="line">TouchDownRepeat：多点触摸按下事件，点触计数大于1，按下第2、3或第4根手指的时候</div><div class="line">TouchDragInside：触摸在控件内拖动时</div><div class="line">TouchDragOutside：触摸在控件外拖动时</div><div class="line">TouchDragEnter：触摸从控件之外拖动到内部时</div><div class="line">TouchDragExit：触摸从控件内部拖动到外部时</div><div class="line">TouchUpInside：在控件之内触摸并抬起事件</div><div class="line">TouchUpOutside：在控件之外触摸抬起事件</div><div class="line">TouchCancel：触摸取消事件，即一次触摸因为放上太多手指而被取消，或者电话打断</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS从App跳转至系统设置菜单]]></title>
      <url>http://yoursite.com/blog/2016/03/13/openSchemes.html</url>
      <content type="html"><![CDATA[<p>###在每个app中的设置页面都希望能够很方便的让用户开启/关闭消息提醒。方便用户体验。</p>
<h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="built_in">UIApplicationOpenSettingsURLString</span>];</div><div class="line"> <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url]) &#123;</div><div class="line">     [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>定位服务<br>定位服务有很多APP都有，如果用户关闭了定位，那么，我们在APP里面可以提示用户打开定位服务。点击到设置界面设置，直接跳到定位服务设置界面。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定位服务设置界面</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=LOCATION_SERVICES"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line">这样就可以跳到系统设置的定位服务界面啦！</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FaceTime</div><div class="line"><span class="comment">//FaceTime设置界面</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=FACETIME"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">音乐</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//音乐设置界面</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=MUSIC"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">墙纸设置界面</div><div class="line"></div><div class="line"><span class="comment">//墙纸设置界面</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=Wallpaper"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">蓝牙设置界面</div><div class="line"></div><div class="line"><span class="comment">//蓝牙设置界面</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=Bluetooth"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</div><div class="line">&#123;</div><div class="line">   [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iCloud设置界面</div><div class="line"></div><div class="line"><span class="comment">//iCloud设置界面</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=CASTLE"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url]</div><div class="line">&#123;</div><div class="line">   [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="还有一些其他的。就不一一举例了。"><a href="#还有一些其他的。就不一一举例了。" class="headerlink" title="还有一些其他的。就不一一举例了。"></a>还有一些其他的。就不一一举例了。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">prefs:root=General&amp;path=About</div><div class="line">prefs:root=General&amp;path=ACCESSIBILITY</div><div class="line">prefs:root=AIRPLANE_MODE</div><div class="line">prefs:root=General&amp;path=AUTOLOCK</div><div class="line">prefs:root=General&amp;path=USAGE/CELLULAR_USAGE</div><div class="line">prefs:root=Brightness</div><div class="line">prefs:root=General&amp;path=Bluetooth</div><div class="line">prefs:root=General&amp;path=DATE_AND_TIME</div><div class="line">prefs:root=FACETIME</div><div class="line">prefs:root=General</div><div class="line">prefs:root=General&amp;path=Keyboard</div><div class="line">prefs:root=CASTLE</div><div class="line">prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</div><div class="line">prefs:root=General&amp;path=INTERNATIONAL</div><div class="line">prefs:root=LOCATION_SERVICES</div><div class="line">prefs:root=ACCOUNT_SETTINGS</div><div class="line">prefs:root=MUSIC</div><div class="line">prefs:root=MUSIC&amp;path=EQ</div><div class="line">prefs:root=MUSIC&amp;path=VolumeLimit</div><div class="line">prefs:root=General&amp;path=Network</div><div class="line">prefs:root=NIKE_PLUS_IPOD</div><div class="line">prefs:root=NOTES</div><div class="line">prefs:root=NOTIFICATIONS_ID</div><div class="line">prefs:root=Phone</div><div class="line">prefs:root=Photos</div><div class="line">prefs:root=General&amp;path=ManagedConfigurationList</div><div class="line">prefs:root=General&amp;path=Reset</div><div class="line">prefs:root=Sounds&amp;path=Ringtone</div><div class="line">prefs:root=Safari</div><div class="line">prefs:root=General&amp;path=Assistant</div><div class="line">prefs:root=Sounds</div><div class="line">prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</div><div class="line">prefs:root=STORE</div><div class="line">prefs:root=TWITTER</div><div class="line">prefs:root=General&amp;path=USAGE</div><div class="line">prefs:root=VIDEO</div><div class="line">prefs:root=General&amp;path=Network/VPN</div><div class="line">prefs:root=Wallpaper</div><div class="line">prefs:root=WIFI</div><div class="line">prefs:root=INTERNET_TETHERING</div></pre></td></tr></table></figure>
<h4 id="如果你想跳转到本app的页面-就需要用这句。"><a href="#如果你想跳转到本app的页面-就需要用这句。" class="headerlink" title="如果你想跳转到本app的页面 就需要用这句。"></a>如果你想跳转到本app的页面 就需要用这句。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift中 core Foundation的运用]]></title>
      <url>http://yoursite.com/blog/2016/02/15/coreFoundation.html</url>
      <content type="html"><![CDATA[<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括你实例化了的 Core Foundation 对象。在 Swift 中，你可以自由变换 Fundation 和 Core Foundation 类型。如果你想先转换为桥接 Foundation 类型时，你也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>
<h4 id="1-重定义类型"><a href="#1-重定义类型" class="headerlink" title="1.重定义类型"></a>1.重定义类型</h4><p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除Ref，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>
<p>Core Foundation 中的CFTypeRef类型会对Anyobject类型重映射。所以你以前使用的CFTypeRef，现在该换成AnyObject了。<br><a id="more"></a></p>
<h4 id="2-内存管理对象"><a href="#2-内存管理对象" class="headerlink" title="2.内存管理对象"></a>2.内存管理对象</h4><p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理–你不再需要调用自身的CFRetain，CFRelease，或者CFAutorelease函数。如果你从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，你需要用CF_RETURNS_RETAINED或者CF_RETURNS_NOT_RETAINED注释这个对象。当 Swift 代码中包含这些 APIs 时，编译器会在编译时自动调用内存管理。如果你只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在你可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>
<h4 id="3-非托管对象"><a href="#3-非托管对象" class="headerlink" title="3.非托管对象"></a>3.非托管对象</h4><p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个Unmanaged<t>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</t></p>
<p>这里说明了Swift是怎么导入的:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-529b451c7d6528cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unmanaged 为未被管理的类型"></p>
<p>假设您从 unannotated APIs 接收了非托管的对象，在使用它之前，你必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮你进行内存管理而不用自己动手。同时，Unmanaged<t>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象–takeUnretainedValue()方法和takeRetainedValue()方法。这两个方法会返回原始的，非封闭的对象类型。您可以根据您实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</t></p>
<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放CFString对象。在使用这个对象前，您使用takeUnretainedValue()函数，以将它转换为一个能够内存管理托管的对象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-40bf81a6ea664a9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unmanaged 未被管理"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> let firstName =  ABRecordCopyValue(person, kABPersonFirstNameProperty).takeRetainedValue()</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-32bc743c44817cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-6bb676ba42cc7dc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>这样的话 你就可以把这个属性转换成任意类型了。</p>
<p>下边说一下ios9 新出的  ContactsUI 来代替  AddressBookUI<br>太简单了。这个就是面对对象来操作的。</p>
<p>首先设置属性以及代理。以及遵守协议。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">viewController: <span class="built_in">UIViewController</span>,<span class="built_in">CNContactPickerDelegate</span> &#123;</div><div class="line"></div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        let vc = <span class="built_in">CNContactPickerViewController</span>()</div><div class="line">        vc.delegate = <span class="keyword">self</span></div><div class="line">        <span class="keyword">self</span>.presentViewController(vc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure></p>
<p>然后实现代理方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func contactPicker(picker: CNContactPickerViewController, didSelectContact contact: CNContact) &#123;</div><div class="line">        </div><div class="line">        let name = contact.familyName</div><div class="line">        print(name)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>contact 装的都是对象属性。<br>哪里不会点哪里</p>
<pre><code>public var identifier: String { get }

 public var contactType: CNContactType { get }

 public var namePrefix: String { get }
 public var givenName: String { get }
 public var middleName: String { get }
 public var familyName: String { get }
 public var previousFamilyName: String { get }
 public var nameSuffix: String { get }
 public var nickname: String { get }

 public var phoneticGivenName: String { get }
 public var phoneticMiddleName: String { get }
 public var phoneticFamilyName: String { get }

 public var organizationName: String { get }
 public var departmentName: String { get }
 public var jobTitle: String { get }

 public var note: String { get }

 @NSCopying public var imageData: NSData? { get }
 @NSCopying public var thumbnailImageData: NSData? { get }
 @available(iOS 9.0, *)
 public var imageDataAvailable: Bool { get }

 public var phoneNumbers: [CNLabeledValue] { get }
 public var emailAddresses: [CNLabeledValue] { get }
 public var postalAddresses: [CNLabeledValue] { get }
 public var urlAddresses: [CNLabeledValue] { get }
 public var contactRelations: [CNLabeledValue] { get }
 public var socialProfiles: [CNLabeledValue] { get }
 public var instantMessageAddresses: [CNLabeledValue] { get }

 /*! The Gregorian birthday. */
 @NSCopying public var birthday: NSDateComponents? { get }

 /*! The alternate birthday (Lunisolar). */
 @NSCopying public var nonGregorianBirthday: NSDateComponents? { get }
</code></pre><p>是不是比core foundation爽多了？？？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift中 覆盖(重写)，重构，重载的区别]]></title>
      <url>http://yoursite.com/blog/2016/02/15/overLoad.html</url>
      <content type="html"><![CDATA[<ul>
<li>重构, 是对软计设计方法的描述, 这个层面是架构和设计方法。</li>
<li>重构是一个软件维护的通用技巧, 重构的具体做法, 可以通过重写或者重载等, 但不限于此, 更改注释, 更改函数名类名等,都可以称之为重构。<blockquote>
<p>你今天写了一个应用, 读txt文档并显示, 几天后,用户的新需求来了, 告诉你, 我要读一个XML文本并显示, 这个时候, 你从前的代码需要做变更, 这个变更的动作, 就叫做重构。<br>你维护的模块有个类叫做Class_B, 别人不爽, 觉得名字不好理解, 要你更改成TXTReader, 并附上注释。</p>
<a id="more"></a></blockquote>
</li>
<li>覆盖(重写), 即override(Overwrite), 表达的都是一个含义。<blockquote>
<p>父类的protect或者public方法无条件的成为子类的方法，但子类不爽， 想要将继承过来的方法改造一下。 这就是重写。<br>参数值，都是一模一样的。但内容体(方法中的代码)已经不同了。</p>
</blockquote>
</li>
<li>重载(Overload)就是通过方法的参数识别不同的函数。<blockquote>
<p>比如你有一个AMethod()不带参数, 然后你用了一个另外相同名称的方法,带一个参数AMethod(String para)。<br>这个过程就叫做重载。</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ios10以及Xcode8的一些更新（转）]]></title>
      <url>http://yoursite.com/blog/2015/09/10/xcode8.html</url>
      <content type="html"><![CDATA[<p>本文主要是一些对iOS新功能的探索，之前发现博客里关于iOS新功能的分析大多是过于概括，每个功能几句话，无法了解到具体的功能。所以本次的探索是基于Api层面，着重看一些具体用法所做的笔记，本来想分别画个类图来着，后来还是觉得太耗时而放弃。如果不想把苹果iOSSDK里的.h文件都摆出来详细读，那看这篇笔记应该是个不错的选择。</p>
<p> 本文以文档的目录为基础，提到的功能模块有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Proactive Suggestions</div><div class="line"></div><div class="line">Integrating with the Messages App</div><div class="line"></div><div class="line">User Notifications</div><div class="line"></div><div class="line">Speech Recognition</div><div class="line"></div><div class="line">Wide Color</div><div class="line"></div><div class="line">Adapting to the True Tone Display</div><div class="line"></div><div class="line">App Search Enhancements</div><div class="line"></div><div class="line">Widget Enhancements</div><div class="line"></div><div class="line">Security and Privacy Enhancements</div></pre></td></tr></table></figure>
<p>还没有详细探索的模块是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SiriKit </div><div class="line"></div><div class="line">CallKit （工作职能和这里联系不多，还不care这里）</div><div class="line"></div><div class="line">Apple Pay Enhancements （工作职能和这里联系不多，还不care这里）</div></pre></td></tr></table></figure>
<h2 id="SiriKit"><a href="#SiriKit" class="headerlink" title="SiriKit"></a>SiriKit</h2><p> SiriKit的功能非常强大，支持音频、视频、消息发送接收、搜索照片、预订行程、管理锻炼等等。在用到此服务时，siri会发送Intent对象，里面包括用户的请求和各种数据，可以对这个intent处理选择适当的响应。 这个功能主要是看这两个头文件（#import <intents intents.h="">、#import <intentsui intentsui.h="">）所涵盖到的类太多，前期先略过了，之后等iOS10可以推送更新了再做进一步调研。</intentsui></intents></p>
<h2 id="Proactive-Suggestions-系统预先建议"><a href="#Proactive-Suggestions-系统预先建议" class="headerlink" title="Proactive Suggestions 系统预先建议"></a>Proactive Suggestions 系统预先建议</h2><h4 id="背景就是iOS9的时候系统给予的主动建议会通过：Spolight搜索，Safari搜索，Handoff，或者siri建议。-在iOS10之后新增了，键盘QuickType建议，地图，车载娱乐，应用切换，siri交互，锁屏播放。-比如你正在一个应用里看一个酒店，可以使用mapitem属性保存正在查看的这个酒店的位置，然后你切换旅行或地图App时这个位置可以自动提供使用。-如果你需要这样利用系统来共享一个位置，那你需要指定这个位置的经纬度，地名-电话等属性-来便于siri的直接调起。"><a href="#背景就是iOS9的时候系统给予的主动建议会通过：Spolight搜索，Safari搜索，Handoff，或者siri建议。-在iOS10之后新增了，键盘QuickType建议，地图，车载娱乐，应用切换，siri交互，锁屏播放。-比如你正在一个应用里看一个酒店，可以使用mapitem属性保存正在查看的这个酒店的位置，然后你切换旅行或地图App时这个位置可以自动提供使用。-如果你需要这样利用系统来共享一个位置，那你需要指定这个位置的经纬度，地名-电话等属性-来便于siri的直接调起。" class="headerlink" title="背景就是iOS9的时候系统给予的主动建议会通过：Spolight搜索，Safari搜索，Handoff，或者siri建议。 在iOS10之后新增了，键盘QuickType建议，地图，车载娱乐，应用切换，siri交互，锁屏播放。 比如你正在一个应用里看一个酒店，可以使用mapitem属性保存正在查看的这个酒店的位置，然后你切换旅行或地图App时这个位置可以自动提供使用。  如果你需要这样利用系统来共享一个位置，那你需要指定这个位置的经纬度，地名,电话等属性 来便于siri的直接调起。"></a>背景就是iOS9的时候系统给予的主动建议会通过：Spolight搜索，Safari搜索，Handoff，或者siri建议。 在iOS10之后新增了，键盘QuickType建议，地图，车载娱乐，应用切换，siri交互，锁屏播放。 比如你正在一个应用里看一个酒店，可以使用mapitem属性保存正在查看的这个酒店的位置，然后你切换旅行或地图App时这个位置可以自动提供使用。  如果你需要这样利用系统来共享一个位置，那你需要指定这个位置的经纬度，地名,电话等属性 来便于siri的直接调起。</h4><p> 文档中还列出了几种场景</p>
<p> 1.在输入框（UITextFiled）输入时，可以指定一下这个输入框的类型，以便系统可以分析出用户的语义。 是电话类型就建议一些电话，是地址类型就建议一些地址。看下头文件（#import <uikit uitextinputtraits.h="">）可指定的类型 就是这个新增的textContentType字段，里面有很多种类型可选。</uikit></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeName                      NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeNamePrefix                NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeGivenName                 NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeMiddleName                NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeFamilyName                NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeNameSuffix                NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeNickname                  NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeJobTitle                  NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeOrganizationName          NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeLocation                  NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeFullStreetAddress         NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeStreetAddressLine1        NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeStreetAddressLine2        NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeAddressCity               NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeAddressState              NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeAddressCityAndState       NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeSublocality               NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeCountryName               NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypePostalCode                NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeTelephoneNumber           NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeEmailAddress              NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeURL                       NS_AVAILABLE_IOS(10_0);</div><div class="line">UIKIT_EXTERN NSString *const UITextContentTypeCreditCardNumber          NS_AVAILABLE_IOS(10_0);</div></pre></td></tr></table></figure>
<p>2.如果是视频类App可以使用MPPlayableContentManager （#import <mediaplayer mpplayablecontentmanager.h="">）看了下，新增了一个属性nowPlayingIdentifiers，苹果的意思应该是只要你以前是用这个多媒体类播放音乐的我就可以让你在锁屏页面交互，需要配置在这个数组里。</mediaplayer></p>
<p>3.如果是出行类app可以使用MKDirectionsRequest。 （#import <mapkit mkdirectionsrequest.h="">  ）这个类里几乎没有新增api，iOS10就新增了一个枚举，而且看上去就是个默认值。如果要使用此功能，需要配置在info.plist文件里 新增key - value ，MKDirectionsApplicationSupportedModes - MKDirectionsModeRideShare。</mapkit></p>
<h2 id="User-Notifications-用户通知"><a href="#User-Notifications-用户通知" class="headerlink" title="User Notifications 用户通知"></a>User Notifications 用户通知</h2><p> 总体的意思就是支持了很多用户定义的通知，并且可以捕捉到各个通知状态的回调。以往通知的概念是：大家想接收的都提前做好准备，然后一下全量分发，没收到也不管了，也不关心发送者。现在用户通知做成了和网络请求有点像 一个先发request再得到response的流程，甚至封装了error，可以在各个状态的方法中做一些额外操作，并且也能取到一些字段，如发送者等。</p>
<p>此功能的头文件入口在#import <usernotifications usernotifications.h=""><br><img src="http://upload-images.jianshu.io/upload_images/1954780-7a6c2ffa9bb15c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="717809-20160620194852069-1522419410.png"></usernotifications></p>
<p> 1.NSString+UserNotifications.h</p>
<p>有一个方法 localizedUserNotificationStringForKey: arguments: （提供该通知被呈现时的本地化字符串），猜测下面的类有很多initWithIdentifier的，他们的indentifier就是这个。</p>
<p>2.UNError.h</p>
<p>有一个属性UNErrorDomain 和一个枚举 UNErrorCode，顾名思义。</p>
<p>3.UNNotification.h</p>
<p>里面有两个属性，date日期 和 request，这个request是上面“8”的类型UNNotificationRequest，点进去看了下比较清晰，有identifier标识，content内容，trigger触发条件， 和带上这三个东西的初始化方法。 其中内容 和 触发条件这两个属性，分别是上面“7” 和 “12”的类型，这个下面再谈。</p>
<p>4.UNNotificationAction.h</p>
<p>这个类突出的是一个通知的动作，有identifier，title，options（枚举，就是通知当前的权限，允许？拒绝？前台时允许？）属性。然后就是带上这三个东西的初始化方法。 然后比较费解的就是下面有一个子类UNTextInputNotificationAction ，这个子类有两个额外属性， 按钮title，和文本框placeholder， 为什么会是这两个属性？ 莫非是点击通知后下拉出的快速回复，有一个输入框和一个按钮。</p>
<p>5.UNNotificationAttachment.h</p>
<p>这个里面就是URL（资源url属性），type（附件类型）。 然后是带上这两个属性的初始化方法。 下面声明了几个字符串常量，暂时还不知道具体用在哪里，typeHint，hiddenKey，clippingRectKey，TimeKey。</p>
<p>6.UNNotificationCategory.h</p>
<p>有indentifier属性，actions（里面是数组），minimalActions（最重要的数组，就是只能给你两个位置显示你显示哪两个，这么个意思），intentIdentifiers属性（应该是和上面的动作数组关联的吧），options（权限相关，无？允许自定义关闭？允许车载系统交互？）。最后就是把这些都带上的init方法。  猜测这个类之所以取名叫category应该是，在某个地方展示通知的时候会把所有通知一一分类， 然后每个类别的通知可能最多只能让你展示几个，如果不做限制应该会展示全部通知，如果权限设置的是允许自定义关闭那可能就是支持类似一键清除的操作。</p>
<p>7.UNNotificationContent.h</p>
<p>消息的内容，一看就能知道应该是一个类似于Entity的东西，里面装有大量的属性：attachments（可选的附件集合），badge（小红点数量），body，categoryIndentifier，launchImageName（从消息里点开的应用程序应该能看到启动图对吧），subtitle，threadIdentifier（与request关联），title，userInfo，sound这个是“11”的类型，应该是同时来时的声音，点开“11”看一下 ，就俩方法，defaultSound，soundNamed: 自定义声音，都在~/Library/Sounds 目录下。 恩再回到刚才那个content类里面有个子类UNMutableNotificationContent，属性和父类相同，只不过是子类的属性都可以修改了，父类的那些属性都是readonly的。</p>
<p>8.UNNotificationRequest.h 上面第3条说过了</p>
<p>9.UNNotificationResponse.h </p>
<p>有action，也有request，那也就有response，这里面有两个属性，notification，actionIdentifier  响应里就这俩破玩意。 然后有个子类UNTextInputNotificationResponse， 这里面就一个属性userText ，看命名很好猜，应该就是前面说的那个有输入框里输入的内容。</p>
<p>10.UNNotificationSettings.h</p>
<p>这个类里就是一些设置了，有一个枚举说的是有没有权限，一个枚举说的是不支持？禁用？启用？。 然后下面一大波属性，小红点设置，声音设置，弹窗设置等等 都是这个枚举类型， 最后还有个alertStyle属性（枚举，None？Banner？alert？）。</p>
<p>11.sound前面第7条说过了</p>
<p>12.UNNotificationTrigger.h</p>
<p>有一个属性 repeats（是否重复发通知）。 下面有四个子类，push通知触发， 时间通知触发，日历通知触发，地区通知触发， 时间的有timeInterval属性， 日历的有dateComponents属性。 然后时间和日历的子类都有nextTriggerDate 方法。</p>
<p>13.UNUserNotificationCenter.h</p>
<p>这里面东西多到吐了，同学你记得NSNotificationCenter么？ 需要提一点的就是以前的通知中心有个方法[NSNotificationCenter defaultCenter]， 这里是[UNUserNotificationCenter currentNotificationCenter]， 提醒一下到时候别说敲不出来。 方法大多是一些remove，add，get等操作， 还有2个代理方法：通知将要发出去时调用，收到通知的response后调用。</p>
<p>14.UNNotificationServiceExtension.h</p>
<p>里面有两个方法，收到通知的请求后调用， 系统将要销毁时调用。</p>
<p>通知里面有UI相关的类 #import <usernotificationsui usernotificationsui.h=""></usernotificationsui></p>
<p>这个类里面就一个文件， 而且方法比较单一，就是收到通知调用，和收到通知的响应调用。 其他方法也就是mediaPlay 和 mediaPause 。和一些多媒体播放的按钮frame，color等， 这里面的作用难道仅仅就是通知来了后播放的音乐暂时暂停下，响一声通知，再播放？ 具体WWDC2016上说的锁屏页面的通知样式处理的api是在下面的部件增强章节中。</p>
<h2 id="Integrating-with-the-Messages-App-与系统短信-app交互"><a href="#Integrating-with-the-Messages-App-与系统短信-app交互" class="headerlink" title="Integrating with the Messages App 与系统短信 app交互"></a>Integrating with the Messages App 与系统短信 app交互</h2><p>对消息额支持很大，可以模拟发消息收消息，发邮件等，提供了UI界面。 也提供了一些额外扩展的api，如表情包区域。WWDC2016上说的各种消息内的新操作在头文件中都能找到Api。</p>
<p>此功能的头文件入口在#import <messages messages.h=""></messages></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-61722c20f74fbe68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="717809-20160620165536303-1502683347.png"></p>
<p>1.MSMessagesAppViewController.h</p>
<p>这个类应该就是苹果自己的消息界面，你可以继承他写你自己自定义的界面。 属性有：activeConversation 指的是当前的会话对象，是上面“2”这个类型，具体详细可以看下面的第“2”点、还有个是presentationStyle（外观样式，枚举类型，紧缩？扩张？）。 接下来就是方法了：requestPresentationStyle（请求消息过渡到指定的样式），dismiss消除方法。 然后就是一波生命周期方法了，每一类都有will和did，会话信息将要（已经）活跃时，将要（已经）解除活跃，将要（已经）选择信息，将要（已经）收到信息，将要（已经）开始发送，将要（已经）取消发送，将要（已经）开始过渡。</p>
<p>2.MSConversation.h</p>
<p>属性有localParticipantIdentifier（当前会话参与者生成的标识，他说只有删了App才会变 姑且理解成id是不会变的），remoteParticipantIdentifiers（远端的标识符数组），selectedMessage（选中的信息），以及4个对象方法 插入一条信息，插入一个标签，插入一段文本，插入一个附件。 这四个方法都有成功的回调。</p>
<p>3.MSSession.h</p>
<p>这个类里面是空的，解释说是用session来处理消息序列间的关系。可能就是占个位，以后估计会添加东西。 这个MSSession是后面很多参数的类型，应该就是区分消息类似于标识符的作用。 </p>
<p>4.MSMessage.h</p>
<p>初始化方法是initWithSession ，没错就是上面那个MSSession。 除了初始化方法剩下的就全是属性了：session，senderParticipantIdentifier（发送者的标识符），layout布局这个是“5”这个类型，URL，shouldExpire（选yes会自动消失，用户手动选择为这条消息续命），accessibilityLabel（残疾人模式支持），error。</p>
<p>5.MSMessageLayout.h</p>
<p>这个是抽象类，里面是空的，就是个布局文件，继承自NSObject。</p>
<p>6.MSMessageTemplateLayout.h</p>
<p>继承上面那个类，看名字是模板布局后面应该会用的挺多的，里面的属性有，标题，子标题，尾部标题，尾部子标题，图片，多媒体URL，图片标题，图片子标题。 </p>
<p>7.MSSticker.h</p>
<p>应该是消息上的表情包。 里面就有两个属性imageFileURL ，localizedDescription 图片和局部描述。然后是带上这两个属性的初始化方法 initWithContentsOfFileURL: localizedDescription: 。</p>
<p>8.MSStickerView.h</p>
<p>这个类就是一个view，里面包着一个sticker，也就是包裹着上面那个装饰品的view。 提供了带上sticker的初始化方法，一个常规属性animationDuration，和三个方法startAnimating，stopAnimating，isAnimating。</p>
<p>9.MSStickerBrowserViewDataSource.h</p>
<p>细思极恐，这个类不就是wwdc2016上说的那个可以在消息下面添加自定义表情的地方么。 符合datasource的风格，里面就两个方法，numberOfStickersInStickerBrowserView: （返回一个总数），stickerBrowserView：stickerAtIndex：（返回这个索引下的内容）。</p>
<p>10.MSStickerBrowserView.h</p>
<p>上面那个是datasource，那这个就是用了上面数据源的view呗。 除了初始化方法，有两个属性 stickerSize（枚举，小，中，大），dataSource（就是上面的“9”），还有个人reloadData方法。</p>
<p>11.MSStickerBrowserViewController.h</p>
<p>上面是个view， 这个就是承载上面那个view的viewcontroller。肯定得有这个属性stickerBrowserView 和初始化方法。</p>
<p>这个message模块还有UI相关的api   #import <messageui messageui.h=""></messageui></p>
<p>就是两个VC ,MFMailComposeViewController,MFMessageComposeViewController。 这两个都是继承自UINavigationController.   觉得这两个就是发邮件的编辑页面，和发消息的编辑页面。  发邮件的页面里有 canSendMail （Bool方法），set主题，set发件人，set收件人，set内容，set附件。 然后有一个代理，和代理方法，猜也能猜到 就是成功失败回调。mailComposeController:didFinishWithResult: error:  。 那另一个消息和这差不多了就不说了。</p>
<h2 id="Speech-Recognition-语音识别转文字"><a href="#Speech-Recognition-语音识别转文字" class="headerlink" title="Speech Recognition 语音识别转文字"></a>Speech Recognition 语音识别转文字</h2><p>这个类里面的Api和方法调用都非常清晰，感觉使用起来会非常方便。真的为科大讯飞捏把汗了，科大讯飞的app（录音宝）我看过，都还没有说一段语音能直接转文字的功能，他们是直接把声音文件上传，然后24小时候再发给你转换后的结果…而且一上来就要收费。苹果的这个功能已经做到了系统原生支持，真的厉害。</p>
<p>此功能的头文件入口在#import <speech speech.h=""></speech></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-ce6606e8d2a0daaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="717809-20160619182921085-1315021923.png"></p>
<p> 1.SFSpeechRecognitionResult.h</p>
<p>这个类里有三个属性：bestTranscription 就是最优的转化结果咯，是上面的“7”这个类型的。然后再看下这个SFTranscription.h ，果然不出所料 有两个属性 一个是字符串类型formattedString 一个是数组类型的segments ，恩 前者就是转化后的字符串，后者是分割后的一个个小结果集合。 然后这个分割的一个个小结果呢又是上面“6”这个类型。那再看一下“6” 里面的属性就是 substring， 时间戳，duration，准确性，备选答案数组，这些很清晰的东西了。</p>
<p>2.SFSpeechRecognitionRequest.h</p>
<p>这个类里东西有点多，属性taskHint，是上面“4”这个类型，点开一看就是一个枚举，用来区分你这个语音识别的请求是哪一类的 查找？确认？听写？无法识别？。 接下来是两个BOOL类型的，shouldReportPartialResults（是否语音局部的一块一块也要处理？默认选false就是一句话全说完了再上传吧），detectMultipleUtterances（假如你说了10秒钟，只有后5秒匹配到了结果，那你前面删了还是保留？默认不删），然后是分析到的关键字数组，和标识符什么的。 然后这个request有两个子类，一个是从本地URL读取 一个声音文件去识别， 一个是默认做法用话筒和AVFoundation库接收到声音去识别，然后有几个拼接声音的API。</p>
<p>3.SFSpeechRecognitionTask.h</p>
<p>从名字就能看出来这是语音识别最重要的一个类了，里面的属性有：state这是一个枚举，说明当前状态是进行中？已完成？被取消？等等。 接下来是三个常见的 isFinishing ，isCancelled ，error 。 接下来是 isPowerAvailable （是否开启说话声音大小的监测？），peakPower（最大声音），averagePower（平均声音）。 属性就这些了，接下来就是一个协议和一波代理方法：刚刚识别出话语调用，猜测话语时调用，话说完了调用，取消时调用，等等等，你能想到的回调方法苹果应该都有的。</p>
<p>4.上面第2条里面说过了</p>
<p>5.SFSpeechRecognizer.h</p>
<p>和系统的那些相机权限，通讯录权限有点像， 就是现在的状态是什么？同意？拒绝？还是未选择过？ 然后提供了方法让用户去选择。 然后有些属性：NSSet类型的supportedLocales（支持地区方言的集合），</p>
<p>available是否可用，locale当前地区 ，defaultTaskHint默认类别，request（就是上面说的请求），队列，代理。 然后有个协议和代理方法：发现用户给与的权限发生改变时调用。</p>
<p>6和7. 上面第1条里说过了 </p>
<h2 id="Wide-Color-宽域颜色"><a href="#Wide-Color-宽域颜色" class="headerlink" title="Wide Color 宽域颜色"></a>Wide Color 宽域颜色</h2><p>文档的原话说：大多数的 core字打头的图形框架 还有AVFoundation 都大大提高了对扩展像素和宽色域色彩空间的支持。通过图形堆栈扩展这种方式比以往支持广色域的显示设备更加容易。现在对UIKit扩展可以在sRGB的色彩空间下工作，性能更好，也可以在更广泛的色域来搭配sRGB颜色。 然后说了几个场景说建议你用sRGB吧，比如依赖于UIkit的clamp component values的应用程序，或是使用较低级别api执行自己图像处理的 都建议用sRGB吧。</p>
<p>然后看了下UIColor类里 到底什么是sRGB？ 发现多了两个iOS10新增的api。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIColor</span> *)colorWithDisplayP3Red:(<span class="built_in">CGFloat</span>)displayP3Red green:(<span class="built_in">CGFloat</span>)green blue:(<span class="built_in">CGFloat</span>)blue alpha:(<span class="built_in">CGFloat</span>)alpha <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);  </div><div class="line"> </div><div class="line">- (<span class="built_in">UIColor</span> *)initWithDisplayP3Red:(<span class="built_in">CGFloat</span>)displayP3Red green:(<span class="built_in">CGFloat</span>)green blue:(<span class="built_in">CGFloat</span>)blue alpha:(<span class="built_in">CGFloat</span>)alpha <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div></pre></td></tr></table></figure>
<p> 细节都是一样的就是一个类方法一个实例方法， 我理解下，就是说建议你们以前改用colorwithRGB的地方 现在都换成这个方法叭。可能大多数公司都抽成了 RGB(a,g,b,a)这种宏吧，那就在宏定义那改一下就好了。</p>
<h2 id="Adapting-to-the-True-Tone-Display-真彩色显示"><a href="#Adapting-to-the-True-Tone-Display-真彩色显示" class="headerlink" title="Adapting to the True Tone Display 真彩色显示"></a>Adapting to the True Tone Display 真彩色显示</h2><p>真彩色的显示会根据光感应器来进行自动的调节来达到特定环境下的显示与性能平衡效果。 如果需要这个功能的话需要再info.plist里配置</p>
<p>UIWhitePointAdaptivityStyle</p>
<p>共有五种选择：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.UIWhitePointAdaptivityStyleStandard 标准</div><div class="line"></div><div class="line">2.UIWhitePointAdaptivityStyleReading 阅读</div><div class="line"></div><div class="line">3.UIWhitePointAdaptivityStylePhoto 图片</div><div class="line"></div><div class="line">4.UIWhitePointAdaptivityStyleVideo 视频</div><div class="line"></div><div class="line">5.UIWhitePointAdaptivityStyleGame 游戏</div></pre></td></tr></table></figure>
<p>然后他说的很清楚，如果你是图片处理类的app，那就直接配stylePhoto吧，如果你是阅读类的那就直接配styleReading吧。 这五个形式的显示效果从上往下递减，我理解是说在阅读时给你最好的效果，但如果在游戏时也给那么好的效果会影响性能，就给你一个相对次一点的显示效果让性能更流畅。</p>
<h2 id="App-Search-Enhancements-应用搜索增强"><a href="#App-Search-Enhancements-应用搜索增强" class="headerlink" title="App Search Enhancements 应用搜索增强"></a>App Search Enhancements 应用搜索增强</h2><p>iOS10的搜索功能做了一定增强：应用程序内搜索，搜索传递，考虑私人差异，结果可视化。 使用CSSearchQuery类，调用Core Spotlight的api，可以让你不必自己维护自己的搜索索引，关于对搜索关键字的处理，还有考虑到不同类别差异导致搜索结果的排序都是苹果帮你处理。</p>
<p>并且搜索结果可以继续往下传递，假设你用Core Spotlight搜索火车站，提示的是地图类app搜索火车站的结果，你点进去后，这个地图类app会接收到“火车站”这个字段在应用内也完成搜索。支持此功能也是需要配置plist文件:key-value  CoreSpotlightContinuation-YES，然后设置CSQueryContinuationActionType（#import<corespotlight cssearchableitem.h="">）。最后传递的搜索字符串用continueUserActivity：restorationHandler：方法接收。</corespotlight></p>
<p>然后现在看一下#import <corespotlight cssearchquery.h="">头文件里面的结构。</corespotlight></p>
<p>看上去这个CSSearchQuery像是一个查询语句操作，有创建，查询成功和错误等。初始化方法是initWithQueryString: attributes:。 有isCanceled属性 和 cancel 和 start方法。 还有foundItemCount属性，看上去是能够得到搜索的结果个数。protectionClasses(数组)，看上去像是隐私相关受保护的文件。 还有两个block，一个是搜索结束后回调，参数是NSError；一个是查询到结果时回调，参数是items数组。这个items数组都是CSSearchableItem类型，这里面有个attributeSet属性，里面可以传入以下类型</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-34f70f5eea73cfae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="717809-20160626110525547-1800081610.png"></p>
<h2 id="Widget-Enhancements-锁屏部件增强"><a href="#Widget-Enhancements-锁屏部件增强" class="headerlink" title="Widget Enhancements 锁屏部件增强"></a>Widget Enhancements 锁屏部件增强</h2><p>现在锁屏界面有了新的设计，建议我们废弃以前的notificationCenterVibrancyEffect 改用widgetPrimaryVibrancyEffect或者widgetSecondaryVibrancyEffect，并且窗口的小部件可以让你描述有多少东西可用，支持紧凑和扩展两种形态。</p>
<p>这些新旧的Effect效果在这个类下，可能是之前锁屏玩不出什么花样所以大家没怎么关注这里。  </p>
<p> #import <notificationcenter notificationcenter.h=""> 里面有三个头文件</notificationcenter></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-113e65e7750da91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="717809-20160621170857694-1224766609.png"></p>
<p> 1.NCWidgetProviding.h</p>
<p>先来两个方法 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)widgetPerformUpdateWithCompletionHandler:(<span class="keyword">void</span> (^)(NCUpdateResult result))completionHandler;</div></pre></td></tr></table></figure>
<p>这个方法如果实现了，系统将在适当的时候召唤部件更新形态，无论是在通知中心还是后台。 需要启用后台更新功能，部件会在异步工作主线程更新，调用参数块的工作完成后会得到相应的结果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(<span class="built_in">CGSize</span>)maxSize;</div></pre></td></tr></table></figure>
<p>这个方法应该是部件变化时调用，参数是最大有多大。</p>
<p>这里声明了一个分类UIVibrancyEffect (NCWidgetAdditions)，里面就是本章节说的iOS10新增API</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIVibrancyEffect</span> *)widgetPrimaryVibrancyEffect <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line"> </div><div class="line">+ (<span class="built_in">UIVibrancyEffect</span> *)widgetSecondaryVibrancyEffect <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div></pre></td></tr></table></figure>
<p>这两个方法名字上是老大和老二，有什么区别？ 都是用在选择的文字或图形上，默认用上面，如果开启了further diminution（应该是类似于上面压缩模式）就用下面的。</p>
<p>下面又声明了一个分类NSExtensionContext (NCWidgetAdditions)，里面也是iOS10的新增API</p>
<p>里面有两个属性 widgetLargestAvailableDisplayMode ，widgetActiveDisplayMode 。 是两种显示模式是NCWidgetDisplayMode枚举类型，有紧缩和扩张两种。 ，估计假如是新闻通知一个是一般大小，一个是点开详情的大小。 然后就是一个方法widgetMaximumSizeForDisplayMode ，返回值是CGSize取到播放模式的最大尺寸。</p>
<p>2.NCWidgetController.h</p>
<p>里面除了个初始化方法，还有一个方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setHasContent:(<span class="built_in">BOOL</span>)flag forWidgetWithBundleIdentifier:(<span class="built_in">NSString</span> *)bundleID;</div></pre></td></tr></table></figure>
<p>第一个参数默认为yes，就是该展示时就展示，这个方法可以跨小组件间通讯，以及和providing app交互。</p>
<p>3.NCWidgetTypes.h</p>
<p>里面就一个枚举类型NCWidgetDisplayMode ，前面第1点说过了。</p>
<h2 id="Security-and-Privacy-Enhancements-安全和保密性增强"><a href="#Security-and-Privacy-Enhancements-安全和保密性增强" class="headerlink" title="Security and Privacy Enhancements 安全和保密性增强"></a>Security and Privacy Enhancements 安全和保密性增强</h2><p>安全方面在iOS10中引入了更多修改和补充，具体有以下几点：</p>
<p>1.在info.plist文件新增了一个key，NSAllowsArbitraryLoadsInWebContent，允许任意web页面加载，同时苹果会用ATS保护你的app。</p>
<p>2.使用改进后的SecKey API 而不是过时的 CDSA API。</p>
<p>3.安全传输API中不再支持SSLv3， 建议你们尽快停用SHA1和3DES加密算法。</p>
<p>4.剪贴板的扩展，因为wwdc2016演示了可以跨设备复制粘贴啊，那肯定要做一些限制可见（#import <uikit uipasteboard.h="">）</uikit></p>
<p>5.这点最重要的，建议尽快适配， 所有和用户权限相关的地方必须在info.plist里配置里面包括</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSBluetoothPeripheralUsageDescription</div><div class="line">NSCalendarsUsageDescription</div><div class="line">NSCameraUsageDescription</div><div class="line">NSContactsUsageDescription</div><div class="line">NSHealthShareUsageDescription</div><div class="line">NSHealthUpdateUsageDescription</div><div class="line">NSHomeKitUsageDescription</div><div class="line">NSLocationAlwaysUsageDescription</div><div class="line">NSLocationWhenInUseUsageDescription</div><div class="line">NSMicrophoneUsageDescription</div><div class="line">NSMotionUsageDescription</div><div class="line">NSPhotoLibraryUsageDescription</div><div class="line">NSRemindersUsageDescription</div><div class="line">NSSiriUsageDescription</div><div class="line">NSSpeechRecognitionUsageDescription</div><div class="line">NSVideoSubscriberAccountUsageDescription</div><div class="line">NSVoIPUsageDescription</div></pre></td></tr></table></figure>
<p>虽然现在还没有iOS10系统的手机，但是我用模拟器试了下，亲测如果我想唤起通讯录但是没有配置NSContactsUsageDescription，刚启动时不会崩溃，但是在唤起操作发生时会直接崩溃。 在info.plist设置之后就可以正常使用了。</p>
<p>本文转自<a href="http://www.cnblogs.com/dsxniubility/p/5596973.html" target="_blank" rel="external">井柏然微博</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cocoaPod的安装，删除以及基本使用]]></title>
      <url>http://yoursite.com/blog/2015/08/13/cocoPod.html</url>
      <content type="html"><![CDATA[<p>如何安装?</p>
<p>1.安装ruby环境,添加淘宝ruby镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gem sources --remove https://rubygems.org/</div><div class="line">//等有反应之后再敲入以下命令</div><div class="line">$ gem sources <span class="_">-a</span> http://ruby.taobao.org/</div></pre></td></tr></table></figure></p>
<p>2.查看是否设置成功:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gem sources <span class="_">-l</span></div></pre></td></tr></table></figure>
<p>3.然后安装cocoapods:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo gem install cocoapods</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>4.查看cocoapods是否支持某个类库</p>
<p>$ pod search 类库名,支持模糊查询(如:AFNetworking)</p>
<p>如何使用?</p>
<ul>
<li>在项目根目录下新建一个“Podfile”的文件(记住一定得叫这个名儿,而且木有后缀)</li>
</ul>
<p>注:Podfile也可以放在任何位置,但是需要在Podfile顶部使用”xcodeproj”关键字指定工程的路径,如下:</p>
<p>Podfile指明xcodeproj</p>
<p>但是执行pod install命令后,生成的文件放在了Podfile所在的目录.</p>
<ul>
<li>编辑Podfile文件输入以下信息</li>
</ul>
<p>platform :iOS, ‘7.0’\所有库支持的IOS最低版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod ‘AFNetworking’, ‘~&gt; 2.0’\\版本号</div></pre></td></tr></table></figure></p>
<p>注:有些第三方库需要指明:platform 支持的IOS最低版本,否则在pod install时会报错,如下图,提示AFNetworking最低支持IOS6.0和OS X 10.8</p>
<p>cocoapods指明ios版本</p>
<ul>
<li>然后在项目podfile所在目录下运行:(会在你当前项目中导入podfile所配置的库,所以要在项目目录下运行)<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod install</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意上述命令运行完毕后终端输出的最后一段话,意思就是以后打开项目就用CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[!] From now on use CocoaPodsDemo.xcworkspace.</div></pre></td></tr></table></figure>
<p>经过以上步骤后,我们现在可以打开CocoaPodsDemo.xcworkspace启动我们的新工程了.新工程中已经通过cocoapods引入并配置好了我们刚在podfile写的需要依赖的第三方库了.</p>
<p>引入第三方库后找不到头文件?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在项目的Targe-Build Settings-Search Paths-User Header Searcj Paths中添加</div><div class="line"></div><div class="line"><span class="variable">$&#123;SRCROOT&#125;</span> 值为 recursive</div></pre></td></tr></table></figure>
<p>如下图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-e42b4ca1f003f6ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>cocoapods<br>配置头文件</p>
<p>如何编译从github上checkout下来的一个已包含CocoPods类库的项目?</p>
<p>打开终端进入你所下载项目的根目录,执行以下命令,后会得到上面的那句话:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod update</div></pre></td></tr></table></figure></p>
<p>等待命令运行完毕后,同样最后会输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[!] From now on use xxxxx.xcworkspace.</div></pre></td></tr></table></figure></p>
<p>如何删除cocopods?</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-0f6de27d590f271f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹</li>
<li>删除xcworkspace文件</li>
<li>使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用</li>
<li>在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources</li>
</ul>
<p>删除cocoapods</p>
<p>CocoaPods常用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1、pod install</div></pre></td></tr></table></figure>
<p>根据Podfile文件指定的内容，安装依赖库，如果有Podfile.lock文件而且对应的Podfile文件未被修改，则会根据Podfile.lock文件指定的版本安装。</p>
<p>每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2、pod update</div></pre></td></tr></table></figure>
<p>若果Podfile中指定的依赖库版本不是写死的，当对应的依赖库有了更新，无论有没有Podfile.lock文件都会去获取Podfile文件描述的允许获取到的最新依赖库版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、pod search</div></pre></td></tr></table></figure>
<p>命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ pod search 类库名,支持模糊查询(如:AFNetworking)</div><div class="line"></div><div class="line">pod search功能</div></pre></td></tr></table></figure>
<p>红框中的信息为AFNetworking 最新版本,Version中显示了历史版本,根据这些信息来编写我们的Podfile文件如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod ‘AFNetWorking’, ‘~&gt; 2.2.4′</div></pre></td></tr></table></figure>
<p>这句话具体含义是什么呢?<br>当我们通过cocopods引入依赖库时，需要显示或隐式注明引用的依赖库版本，具体写法和表示含义如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pod ‘AFNetworking’      //不显式指定依赖库版本，表示每次都获取最新版本</div><div class="line">pod ‘AFNetworking’, ‘2.0’     //只使用2.0版本</div><div class="line">pod ‘AFNetworking’, ‘&gt; 2.0′     //使用高于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘&gt;= 2.0′     //使用大于或等于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘&lt; 2.0′     //使用小于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘&lt;= 2.0′     //使用小于或等于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘~&gt; 0.1.2′     //使用大于等于0.1.2但小于0.2的版本</div><div class="line">pod ‘AFNetworking’, ‘~&gt;0.1′     //使用大于等于0.1但小于1.0的版本</div><div class="line">pod ‘AFNetworking’, ‘~&gt;0′     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4、pod setup</div></pre></td></tr></table></figure>
<p>用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。</p>
<p>①多个target中使用相同的Pods依赖库</p>
<p>比如，名称为CocoaPodsTest的target和Second的target都需要使用Reachability、SBJson、AFNetworking三个Pods依赖库，可以使用link_with关键字来实现，将Podfile写成如下方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">link_with ‘CocoaPodsTest’, ‘Second’</div><div class="line">platform :ios</div><div class="line">pod ‘Reachability’,  ‘~&gt; 3.0.0′</div><div class="line">pod ‘SBJson’, ‘~&gt; 4.0.0′</div><div class="line"></div><div class="line">platform :ios, ‘7.0’</div><div class="line">pod ‘AFNetworking’, ‘~&gt; 2.0′</div></pre></td></tr></table></figure>
<p>这种写法就实现了CocoaPodsTest和Second两个target共用相同的Pods依赖库。</p>
<p>②不同的target使用完全不同的Pods依赖库</p>
<p>CocoaPodsTest这个target使用的是Reachability、SBJson、AFNetworking三个依赖库，但Second这个target只需要使用OpenUDID这一个依赖库，这时可以使用target关键字，Podfile的描述方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">target :’CocoaPodsTest’ <span class="keyword">do</span></div><div class="line">platform :ios</div><div class="line">pod ‘Reachability’,  ‘~&gt; 3.0.0′</div><div class="line">pod ‘SBJson’, ‘~&gt; 4.0.0′</div><div class="line"></div><div class="line">platform :ios, ‘7.0’</div><div class="line">pod ‘AFNetworking’, ‘~&gt; 2.0′</div><div class="line">end</div><div class="line"></div><div class="line">target :’Second’ <span class="keyword">do</span></div><div class="line">pod ‘OpenUDID’, ‘~&gt; 1.0.0′</div><div class="line">end</div></pre></td></tr></table></figure>
<p>其中，do/end作为开始和结束标识符。</p>
<p>Podfile.lock文件</p>
<p>在使用CocoaPods，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。<br>该文件用于保存已经安装的Pods依赖库的版本，通过CocoaPods安装了SBJson、AFNetworking、Reachability三个POds依赖库以后对应的Podfile.lock文件内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">PODS:</div><div class="line">– AFNetworking (2.1.0):</div><div class="line">– AFNetworking/NSURLConnection</div><div class="line">– AFNetworking/NSURLSession</div><div class="line">– AFNetworking/Reachability</div><div class="line">– AFNetworking/Security</div><div class="line">– AFNetworking/Serialization</div><div class="line">– AFNetworking/UIKit</div><div class="line">– AFNetworking/NSURLConnection (2.1.0):</div><div class="line">– AFNetworking/Reachability</div><div class="line">– AFNetworking/Security</div><div class="line">– AFNetworking/Serialization</div><div class="line">– AFNetworking/NSURLSession (2.1.0):</div><div class="line">– AFNetworking/NSURLConnection</div><div class="line">– AFNetworking/Reachability (2.1.0)</div><div class="line">– AFNetworking/Security (2.1.0)</div><div class="line">– AFNetworking/Serialization (2.1.0)</div><div class="line">– AFNetworking/UIKit (2.1.0):</div><div class="line">– AFNetworking/NSURLConnection</div><div class="line">– Reachability (3.0.0)</div><div class="line">– SBJson (4.0.0)</div><div class="line"></div><div class="line">DEPENDENCIES:</div><div class="line">– AFNetworking (~&gt; 2.0)</div><div class="line">– Reachability (~&gt; 3.0.0)</div><div class="line">– SBJson (~&gt; 4.0.0)</div><div class="line"></div><div class="line">```bash</div><div class="line">SPEC CHECKSUMS:</div><div class="line">AFNetworking: c7d7901a83f631414c7eda1737261f696101a5<span class="built_in">cd</span></div><div class="line">Reachability: 500bd76bf6<span class="built_in">cd</span>8ff2c6fb715<span class="built_in">fc</span>5f44ef6e4c024f2</div><div class="line">SBJson: f3c686806e8e36ab89e020189ac582ba26ec4220</div><div class="line"></div><div class="line">COCOAPODS: 0.29.0</div></pre></td></tr></table></figure>
<p>Podfile.lock文件最大得用处在于多人开发。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！<br>在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案：</p>
<ul>
<li>更改Podfile，使其指向最新版本的SBJson依赖库；</li>
<li>执行pod update命令；</li>
</ul>
<p>鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。</p>
<p>如何制作自己的Cocopods库</p>
<p>1.在github上新建一个工程</p>
<p>github上新建pod工程</p>
<p>license类型</p>
<p>正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。</p>
<p>把项目clone到本地然后在根目录下新建MyPodDemo.podspec</p>
<p>或使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ pod spec create MyPodDemo</div></pre></td></tr></table></figure>
<p>Spec文件编写:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new <span class="keyword">do</span> |s|</div><div class="line">s.name = <span class="string">"MyPodDemo"</span></div><div class="line">s.version = <span class="string">"0.0.1"</span></div><div class="line">s.summary = <span class="string">"A short description of MyPodDemo."</span></div><div class="line">s.description = &lt;&lt;-DESC</div><div class="line">A longer description of MyPodDemo <span class="keyword">in</span> Markdown format.</div><div class="line">* Think: Why did you write this? What is the focus? What does it <span class="keyword">do</span>?</div><div class="line">* CocoaPods will be using this to generate tags, and improve search results.</div><div class="line">* Try to keep it short, snappy and to the point.</div><div class="line">* Finally, don<span class="string">'t worry about the indent, CocoaPods strips it!</span></div><div class="line">DESC</div><div class="line">s.homepage = "https://github.com/goingta/MyPodDemo"</div><div class="line">s.license = "MIT"</div><div class="line">s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;</div><div class="line">s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;</div><div class="line">s.source_files = "MyPodDemo/Src", "MyPodDemo/Src/**/*.&#123;h,m&#125;"</div><div class="line">s.requires_arc = true</div><div class="line"># s.framework = "SomeFramework"</div><div class="line"># s.frameworks = "SomeFramework", "AnotherFramework"</div><div class="line"># s.library = "iconv"</div><div class="line"># s.libraries = "iconv", "xml2"</div><div class="line"># s.dependency "JSONKit", "~&gt; 1.4"</div><div class="line"># s.dependency "AFNetworking", "~&gt; 2.2.4"</div><div class="line">end</div></pre></td></tr></table></figure>
<p>自解析:</p>
<p>name: 导入pod后的目录名<br>version: 当前版本号<br>deployment_target: 配置的target<br>prefix_header_file: 预编译头文件路径，将该文件的内容插入到Pod的pch文件内<br>source: 来源的具体路径，是http链接还是本地路径<br>requires_arc: 是否需要arc<br>source_files: 指定该目录下包含哪些文件<br>其他可选参数还包括：<br>dependency: 指定依赖，如果依赖的库不存在或者依赖库的版本不符合要求将会报错<br>libraries: 指定导入的库，比如sqlite3<br>frameworks: 指定导入的framework<br>weak_frameworks: 弱链接，比如说一个项目同时兼容iOS6和iOS7，但某一个framework只在iOS7上有，这时候如果用强链接，那么在iOS7上运行就会crash，使用weak_frameworks可以避免这种情况。</p>
<p>整个podspec语法是一个嵌套结构从Pod::Spec.new do |s|到最后一个end是最大的循环，表示整个podspec导入的文件。中间每一个subspec到end结束是一个子目录，Pods会为每个subspec创建一个逻辑目录，相当于Xcode的group概念。|**|中间是subspec的名字，可以随便命名，但后面使用的名称必须一致。</p>
<p>通配符说明</p>
<p>a{bb,bc}def.{h,m}表示四个文件abbdef.h abbdef.m abcdef.h abcdef.m</p>
<p><em>.{h,m,mm}表示所有的.h .m .mm文件<br>Class/**/</em>.{h,m}表示Class目录下的所有.h .m文件</p>
<p>写完podspec文件后使用pod spec lint验证spec是否合格,有error则需要修改</p>
<p>spec文件验证</p>
<p>上传代码至github</p>
<p>上传podspec文件到CocoaPods仓库(fork一下,修改完成后在push上去等待审核)</p>
<p>链接为：<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="external">将我们刚刚生成的MyPodDemo.spec 文件上传到Cocoapods官方specs仓库中</a></p>
<p>私有库实现,编写podfile</p>
<p>如果由于某些原因我们编写的库不能公开,但是又想使用pods来进行管理,要怎么办呢?</p>
<p>首先我们要将我们刚刚在github上建的仓库改为Private(不然还用Public搞毛啊)</p>
<p>然后修改我们项目的podfile,与已加入Cocopods仓库的公有库相比我们只需要指明私有库低git地址,如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">platform :ios, <span class="string">'6.0'</span></div><div class="line">pod <span class="string">'MyPodDemo'</span>, :git =&gt; <span class="string">'https://github.com/goingta/MyPodDemo.git'</span> //私有库</div><div class="line">pod <span class="string">'CocoaLumberjack'</span>//公有库</div></pre></td></tr></table></figure>
<p><a href="http://bashcn.io/issue-6-4/" target="_blank" rel="external">版本控制和冲突</a></p>
<p>CocoaPods 使用语义版本控制 – Semantic Versioning 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于2.3.1，另一个依赖于 2.3.3，此时冲突解决系统可以使用最新的版本 2.3.3，因为这个可以向后与 2.3.1 兼容。</p>
<p>但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。</p>
<p>当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 1.2.5，另外一个库则依赖于 2.3.1，那么只有最终用户通过明确指定使用某个版本来解决冲突。</p>
<p>配置非ARC文件(8.5号补充)</p>
<p>前几天项目中由于历史原因,导致有一个私有的pods库中某几个文件是在非ARC时代写的,如果要进行修改工程量浩大,于是乎要对这几个文件单独处理,这几个文件不使用arc其他文件使用arc,网上查了一些资料,只需要对source_file进行修改并排除那几个不使用ARC的文件就可以了,大致修改如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new <span class="keyword">do</span> |s|</div><div class="line">s.name = <span class="string">"MyPodDemo"</span></div><div class="line">s.version = <span class="string">"0.0.1"</span></div><div class="line">s.summary = <span class="string">"A short description of MyPodDemo.</span></div><div class="line">s.homepage = "https://github.com/goingta/MyPodDemo<span class="string">"</span></div><div class="line">s.license = "MIT<span class="string">"</span></div><div class="line">s.author = &#123; "goingta<span class="string">" =&gt; "</span>tangle1128@gmail.com<span class="string">" &#125;</span></div><div class="line">s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git<span class="string">", :tag =&gt; "</span>0.0.1<span class="string">" &#125;</span></div><div class="line">s.source_files = "MyPodDemo<span class="string">"</span></div><div class="line">non_arc_files = 'MyPodDemo/NoArcFile1.&#123;h,m&#125;','MyPodDemo/NoArcFile2.&#123;h,m&#125;'</div><div class="line">s.requires_arc = true</div><div class="line"></div><div class="line">s.exclude_files = non_arc_files</div><div class="line">s.subspec 'no-arc' do |sna|</div><div class="line">sna.requires_arc = false</div><div class="line">sna.source_files = non_arc_files</div><div class="line">end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>回退Cocoapods历史版本(2015.3.17号补充)</p>
<p>先删除已经装过的版本(可能有几个,卸载的时候会让你输入1,2..n选择卸载那个版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem uninstall cocoapods</div></pre></td></tr></table></figure>
<p>安装某一个版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods -v 0.35.0</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSDictionary字典的使用以及注意]]></title>
      <url>http://yoursite.com/blog/2015/07/18/NSDictionary.html</url>
      <content type="html"><![CDATA[<p>字典：NSDictionary<br>字典就是关键字及其定义（描述）的集合。</p>
<ul>
<li>Cocoa中的实现字典的集合NSDictionary在给定的关键字（key）下存储一个数值（value）。然后你就可以用这个关键字来查找相应的数值。</li>
<li>字典（也被称为散列表或关联数组）使用的是键查询的优化存储方式。它可以立即找出要查询的数据，而不需要遍历整个数组进行查找。</li>
<li>!注意字典是无序的。数组是有序的。</li>
<li><a id="more"></a>
<blockquote>
<p>!!!!（因为做项目基本数据都会从数据库获取，所以会存在字典为空 或者有字典 但是value 为nil的情况。所以想要获取字典中的值中，就要首先判断。否则会崩溃）<br>!!!!不要判断字典是否存在。<br>!!!!当向nil发送消息时，返回NO，不会有异常，程序将继续执行下去；<br>而向NSNull的对象发送消息时会收到异常。<br>因为在NSArray和NSDictionary中nil中有特殊的含义（表示列表结束），所以不能在集合中放入nil值。如要确实需要存储一个表示“什么都没有”的值，可以使用NSNull类。<br>exam:<br><img src="http://upload-images.jianshu.io/upload_images/1954780-493c5733fb8b812b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>最后我是这样判断的。<br>//前边判断 是否有字典。 后边判断字典里是否有值。<br><img src="http://upload-images.jianshu.io/upload_images/1954780-5bd2b7be372c51ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</blockquote>
</li>
</ul>
<p>使用 <code>setObject:forkey:</code> 方法添加字典元素，如果关键字已存在，则用新植替换旧值。<br>NSMutableDictionary类允许随意添加或删除字典元素。</p>
<ul>
<li>添加元素：setObject:forkey:</li>
<li>删除元素：removeObjectForKey:</li>
</ul>
<h4 id="这是我刚做一个项目得出的结论。如有不对-请大家指出。"><a href="#这是我刚做一个项目得出的结论。如有不对-请大家指出。" class="headerlink" title="这是我刚做一个项目得出的结论。如有不对 请大家指出。"></a>这是我刚做一个项目得出的结论。如有不对 请大家指出。</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于日期格式设置及转换]]></title>
      <url>http://yoursite.com/blog/2015/07/05/dateFormatter.html</url>
      <content type="html"><![CDATA[<p>总结一下关于日期格式的问题汇总。</p>
<h4 id="1-把字符串转化为任意日期时间格式"><a href="#1-把字符串转化为任意日期时间格式" class="headerlink" title="1.把字符串转化为任意日期时间格式"></a>1.把字符串转化为任意日期时间格式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将要转换的字符串</span></div><div class="line"> <span class="built_in">NSString</span>* string = <span class="string">@"20160512134106"</span>;</div><div class="line">    <span class="built_in">NSDateFormatter</span> *inputFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init] ;</div><div class="line"><span class="comment">//将要显示日期的时区。</span></div><div class="line">    [inputFormatter setLocale:[[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US"</span>] ];</div><div class="line"><span class="comment">//显示日期的格式。</span></div><div class="line">    [inputFormatter setDateFormat:<span class="string">@"yyyyMMddHHmmss"</span>];</div><div class="line">    <span class="built_in">NSDate</span>* inputDate = [inputFormatter dateFromString:string];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"date = %@"</span>, inputDate);</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-3517069646bac263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h4 id="连接到上面的代码"><a href="#连接到上面的代码" class="headerlink" title="连接到上面的代码"></a>连接到上面的代码</h4><a id="more"></a>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">NSDateFormatter</span> *outputFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line"><span class="comment">//当前的时区</span></div><div class="line">    [outputFormatter setLocale:[<span class="built_in">NSLocale</span> currentLocale]];</div><div class="line"><span class="comment">//设置格式</span></div><div class="line">    [outputFormatter setDateFormat:<span class="string">@"yyyy年MM月dd日 HH时mm分ss秒"</span>];</div><div class="line">    <span class="built_in">NSString</span> *str = [outputFormatter stringFromDate:inputDate];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testDate:%@"</span>, str);</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-d61668c0a2f686c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h4 id="2-关于NSDateFormatter的格式"><a href="#2-关于NSDateFormatter的格式" class="headerlink" title="2.关于NSDateFormatter的格式"></a>2.关于NSDateFormatter的格式</h4><pre><code>G: 公元时代，例如AD公元
yy: 年的后2位
yyyy: 完整年
MM: 月，显示为1-12
MMM: 月，显示为英文月份简写,如 Jan
MMMM: 月，显示为英文月份全称，如 Janualy
dd: 日，2位数表示，如02
d: 日，1-2位显示，如 2
EEE: 简写星期几，如Sun
EEEE: 全写星期几，如Sunday
aa: 上下午，AM/PM
H: 时，24小时制，0-23
K：时，12小时制，0-11
m: 分，1-2位
mm: 分，2位
s: 秒，1-2位
ss: 秒，2位
S: 毫秒
</code></pre><p>常用日期结构：<br>yyyy-MM-dd HH:mm:ss.SSS<br>yyyy-MM-dd HH:mm:ss<br>yyyy-MM-dd<br>MM dd yyyy</p>
<h4 id="3-设置时间延长。"><a href="#3-设置时间延长。" class="headerlink" title="3.设置时间延长。"></a>3.设置时间延长。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置延时的时间</span></div><div class="line">meInterval secondsPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</div><div class="line"></div><div class="line"><span class="comment">//设置以时间去创建</span></div><div class="line">  <span class="built_in">NSDate</span> * data = [[<span class="built_in">NSDate</span> alloc]initWithTimeIntervalSinceNow:-secondsPerDay];</div><div class="line">    </div><div class="line">    <span class="built_in">NSDateFormatter</span> *outputFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">        [outputFormatter setLocale:[<span class="built_in">NSLocale</span> currentLocale]];</div><div class="line">        [outputFormatter setDateFormat:<span class="string">@"yyyy年MM月dd日 HH时mm分ss秒"</span>];</div><div class="line"> <span class="built_in">NSString</span> *str = [outputFormatter stringFromDate:data];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-3224874d3d22b18b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="现在的时间"><br><img src="http://upload-images.jianshu.io/upload_images/1954780-74e4c0865185e6af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 显示的时间"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OC多线程GCD以及NSoperation]]></title>
      <url>http://yoursite.com/blog/2015/05/16/NSoperation&GCD.html</url>
      <content type="html"><![CDATA[<p>首先讲一下关于线程的基础知识。</p>
<h3 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1.什么是进程？"></a>1.什么是进程？</h3><p>进程是指在系统中正在运行的一个应用程序<br>每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>
<h3 id="2-什么是线程？"><a href="#2-什么是线程？" class="headerlink" title="2.什么是线程？"></a>2.什么是线程？</h3><p>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。<br><a id="more"></a></p>
<h3 id="4-多线程的原理。"><a href="#4-多线程的原理。" class="headerlink" title="4.多线程的原理。"></a>4.多线程的原理。</h3><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象思考：如果线程非常非常多，会发生什么情况？CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源每条线程被调度执行的频次会降低（线程的执行效率降低）</p>
<h3 id="4-多线程的优缺点。"><a href="#4-多线程的优缺点。" class="headerlink" title="4.多线程的优缺点。"></a>4.多线程的优缺点。</h3><p>多线程的优点<br>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）</p>
<p>多线程的缺点<br>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能<br>线程越多，CPU在调度线程上的开销就越大<br>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</p>
<h3 id="5-线程中的属性。"><a href="#5-线程中的属性。" class="headerlink" title="5.线程中的属性。"></a>5.线程中的属性。</h3><p>线程中有4个最主要的名词。</p>
<ul>
<li>同步任务：同步：在当前线程中执行任务，不具备开启新线程的能力。</li>
<li>异步任务：在新的线程中执行任务，具备开启新线程的能力。<br>并发和串行决定了任务的执行方式</li>
<li>并发队列：多个任务并发（同时）执行。</li>
<li>串行队列：一个任务执行完毕后，再执行下一个任务。<br>而主队列是特殊的串行队列。<br>全局队列是特殊的并发队列。<h3 id="6-GCD的基础使用。"><a href="#6-GCD的基础使用。" class="headerlink" title="6.GCD的基础使用。"></a>6.GCD的基础使用。</h3></li>
</ul>
<p>1.串行队列。</p>
<ul>
<li><p>使用dispatch_queue_create函数创建串行队列</p>
<blockquote>
<p> // 队列名称， 队列属性，一般用NULL即可<br>dispatch_queue_t  dispatch_queue_create(const char *label,  dispatch_queue_attr_t attr);</p>
</blockquote>
</li>
<li><p>使用 使用主队列（跟主线程相关联的队列）</p>
<blockquote>
<p>主队列是GCD自带的一种特殊的串行队列,放在主队列中的任务，都会放到主线程中执行<br>使用dispatch_get_main_queue()获得主队列</p>
</blockquote>
</li>
</ul>
<p>2.并发队列。<br> GCD默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建</p>
<p>使用dispatch_get_global_queue函数获得全局的并发队列<br>// 此参数暂时无用，用0即可。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(dispatch_queue_priority_t priority,<span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</div></pre></td></tr></table></figure></p>
<p>GCD 小结： </p>
<blockquote>
<p>其实多线程就是在多个线程之间快速做“切换”的操作（在线程调度池里执行任务）。<br>线程里有个属性是优先级。这个属性决定的是线程有更多的机会去调用。并不是决定任务的先后顺序。<br>而且注意！！！！开发中 一定不要取修改优先级。否则会出现很多你想不到的错误。<br>不能把同步任务加入到主队列中。否则会出现同步锁现象。</p>
</blockquote>
<h3 id="7-NSoperation的基础使用。"><a href="#7-NSoperation的基础使用。" class="headerlink" title="7.NSoperation的基础使用。"></a>7.NSoperation的基础使用。</h3><ul>
<li>并发数<br>（1）并发数:同时执⾏行的任务数.比如,同时开3个线程执行3个任务,并发数就是3<br>（2）最大并发数：同一时间最多只能执行的任务的个数。<br>（3）最⼤大并发数的相关⽅方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSInteger</span>)maxConcurrentOperationCount;- (<span class="keyword">void</span>)setMaxConcurrentOperationCount:(<span class="built_in">NSInteger</span>)cnt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>说明：如果没有设置最大并发数，那么并发的个数是由系统内存和CPU决定的，可能内存多久开多一点，内存少就开少一点。<br>注意：num的值并不代表线程的个数，仅仅代表线程的ID。<br>提示：最大并发数不要乱写（5以内），不要开太多，一般以2~3为宜，因为虽然任务是在子线程进行处理的，但是cpu处理这些过多的子线程可能会影响UI，让UI变卡。</p>
<ul>
<li>队列的取消，暂停和恢复<br>1）取消队列的所有操作<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> - (<span class="keyword">void</span>)cancelAllOperations;</div><div class="line">提⽰:也可以调用<span class="built_in">NSOperation</span>的- (<span class="keyword">void</span>)cancel⽅法取消单个操作</div></pre></td></tr></table></figure>
</li>
</ul>
<p>（2）暂停和恢复队列<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)b; <span class="comment">// YES代表暂停队列,NO代表恢复队列</span></div><div class="line">-(<span class="built_in">BOOL</span>)isSuspended; <span class="comment">//当前状态</span></div></pre></td></tr></table></figure></p>
<p>（3）暂停和恢复的适用场合：在tableview界面，开线程下载远程的网络界面，对UI会有影响，使用户体验变差。那么这种情况，就可以设置在用户操作UI（如滚动屏幕）的时候，暂停队列（不是取消队列），停止滚动的时候，恢复队列。</p>
<p>NSOperation 小结：</p>
<blockquote>
<p>GCD和NSOperation 都各有各的好处。<br>GCD能够开多个线程 但是并不能管理。<br>但是NSOperation 可以管理线程。还可以设置最大操作并发数。<br>而GCD可以使用延时方法 after 和sleep 还有一次性once方法 创建单例对象。<br>根据你所需要的去选择恰当的方法。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于文件下载]]></title>
      <url>http://yoursite.com/blog/2015/04/24/downLoad.html</url>
      <content type="html"><![CDATA[<p>使用xcode自带的代理方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">代理方法：</div><div class="line"><span class="comment">//这个是开始下载时 调用的方法。</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line"><span class="comment">//这个也是每次都在调用的方法。</span></div><div class="line">data(代表每次下载的数据大小)</div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line"></div><div class="line"><span class="comment">//这个方法是在下载时一直会调用的。这里有三个参数。</span></div><div class="line">bytesWritten（代表本次下载下载了多少）</div><div class="line">totalBytesWritten（代表已经下载了多少）</div><div class="line">totalBytesExpectedToWrite（代表文件总大小是多少）</div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection   didSendBodyData:(<span class="built_in">NSInteger</span>)bytesWritten</div><div class="line">                                                 totalBytesWritten:</div><div class="line">(<span class="built_in">NSInteger</span>)totalBytesWritten</div><div class="line">                                         totalBytesExpectedToWrite:(<span class="built_in">NSInteger</span>)totalBytesExpectedToWrite;</div><div class="line"></div><div class="line"><span class="comment">//这个方法在下载完成后 会自动调用。</span></div><div class="line">connection（这个参数是下完完成后 文件的路径）</div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="1-使用NSUrlContionDownloadDelegate"><a href="#1-使用NSUrlContionDownloadDelegate" class="headerlink" title="1.使用NSUrlContionDownloadDelegate."></a>1.使用NSUrlContionDownloadDelegate.</h3><p> 1）内存不会暴涨 但是找不到下载完毕之后的文件。<br> 2）可以直接显示下载进度。</p>
<h3 id="2-使用NSUrlconnectionDataDelegate"><a href="#2-使用NSUrlconnectionDataDelegate" class="headerlink" title="2.使用NSUrlconnectionDataDelegate."></a>2.使用NSUrlconnectionDataDelegate.</h3><p>  直接设置NSMutableData属性来接受下载完毕的数据 .<br>  1）内存依然“暴涨”：相当于还是先将整个文件下载到内存中 然后在写入沙盒中<br>  2) 无法直接显示下载进度。需要手动计算。</p>
<h3 id="3-利用NSfileHanddle"><a href="#3-利用NSfileHanddle" class="headerlink" title="3.利用NSfileHanddle"></a>3.利用NSfileHanddle</h3><ul>
<li>NSFileHandle :文件操作句柄，用来拼接文件。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用已下载的本地路径去创建handle</span></div><div class="line"> <span class="built_in">NSFileHandle</span> * handle = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:<span class="string">@"/Users/ym/Desktop/haha.zip"</span>];</div><div class="line">    <span class="comment">//如果handle创建成功 代表本地路径有文件。</span></div><div class="line">    <span class="keyword">if</span> (handle) &#123;</div><div class="line">        操作句柄到最后</div><div class="line">        [handle seekToEndOfFile];</div><div class="line">        </div><div class="line">        <span class="comment">// 拼接文件/写入文件</span></div><div class="line">        [handle writeData:data];</div><div class="line">        </div><div class="line">        <span class="comment">// 关闭句柄</span></div><div class="line">        [handle closeFile];</div><div class="line">       </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//本地路径没有文件。</span></div><div class="line">就重新创建一个本地文件路径</div><div class="line">        [data writeToFile:<span class="string">@"/Users/ym/Desktop/haha.zip"</span> atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="4-NSOutputStream"><a href="#4-NSOutputStream" class="headerlink" title="4. NSOutputStream"></a>4. NSOutputStream</h4><p>问题:多次下载，会直接在之前的文件后拼接文件—&gt;得不到正确的文件数据。</p>
<p>//首先要根据文件路径来创建stream 。如果你的这个路径没有文件。他会自动给你创建一个文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">   <span class="built_in">NSOutputStream</span> * stream = [<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:<span class="string">@" /Users/ym/Desktop/haha.zip"</span> append:<span class="literal">YES</span>];</div><div class="line"><span class="comment">//创建一个属性。来存储文件和关闭stream</span></div><div class="line">    <span class="keyword">self</span>.stream = stream;</div><div class="line"><span class="comment">//开启任务。</span></div><div class="line">    [<span class="keyword">self</span>.stream open];</div><div class="line"></div><div class="line"><span class="comment">//在方法里 来拼接data内容。</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data&#123;</div><div class="line">    [<span class="keyword">self</span>.stream write:data.bytes maxLength:data.length];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection&#123;</div><div class="line"><span class="comment">//在下载结束任务后，关闭stream任务。</span></div><div class="line">    [<span class="keyword">self</span>.stream close];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的下载任务。还是会有和handle一样的问题。多次下载和暂停下载之后继续下载。拼接的文件都是错误的。</p>
<p>所以这里就引入了断点续传功能。</p>
<p>###用HEAD请求来获取下载文件的总大小</p>
<ul>
<li>HTTP协议方法: HEAD 请求</li>
<li>HEAD 请求: 只获取服务器的响应头信息,不获取文件内容(实体内容).</li>
<li>一般在文件下载的时候,提前获取文件信息.</li>
<li>HEAD请求: 和 GET 请求是一样的.只是不获取文件内容(实体内容).<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径</span></div><div class="line"><span class="built_in">NSString</span> *urlString = <span class="string">@"http://127.0.0.1/music.zip"</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</div><div class="line">    <span class="comment">//创建请求</span></div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置请求方法:</span></div><div class="line">    request.HTTPMethod = <span class="string">@"HEAD"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//  发送 HEAD 请求.</span></div><div class="line">    <span class="comment">// HEAD 请求使用什么方法发送? ---- 一般使用同步方式发送HEAD请求.</span></div><div class="line">    </div><div class="line"> <span class="built_in">NSURLResponse</span> *response = <span class="literal">nil</span>;</div><div class="line">[<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:<span class="literal">NULL</span>];</div><div class="line">    <span class="comment">//打印出来的就是你的所需要的文件总大小。</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"response:%zd"</span>,response.expectedContentLength);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="获取本地路径中-文件的大小。"><a href="#获取本地路径中-文件的大小。" class="headerlink" title="获取本地路径中 文件的大小。"></a>获取本地路径中 文件的大小。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里返回值是一个字典。</span></div><div class="line"> [[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:<span class="keyword">self</span>.filePath error:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个就是打印字典的信息。</span></div><div class="line">我们所需要的就是<span class="built_in">NSFileSize</span></div><div class="line">**  <span class="built_in">NSFileCreationDate</span> = <span class="string">"2016-05-05 12:59:14 +0000"</span>;</div><div class="line">**    <span class="built_in">NSFileExtensionHidden</span> = <span class="number">0</span>;</div><div class="line">**    <span class="built_in">NSFileGroupOwnerAccountID</span> = <span class="number">20</span>;</div><div class="line">**    <span class="built_in">NSFileGroupOwnerAccountName</span> = staff;</div><div class="line">**    <span class="built_in">NSFileModificationDate</span> = <span class="string">"2016-05-05 12:59:17 +0000"</span>;</div><div class="line">**    <span class="built_in">NSFileOwnerAccountID</span> = <span class="number">501</span>;</div><div class="line">**    <span class="built_in">NSFilePosixPermissions</span> = <span class="number">420</span>;</div><div class="line">**    <span class="built_in">NSFileReferenceCount</span> = <span class="number">1</span>;</div><div class="line">**    <span class="built_in">NSFileSize</span> = <span class="number">573278888</span>;</div><div class="line">**    <span class="built_in">NSFileSystemFileNumber</span> = <span class="number">19578034</span>;</div><div class="line">**    <span class="built_in">NSFileSystemNumber</span> = <span class="number">16777217</span>;</div><div class="line">**    <span class="built_in">NSFileType</span> = <span class="built_in">NSFileTypeRegular</span>;</div></pre></td></tr></table></figure>
<p>所以要接收这个字典 同时返回NSFileSize.获取本地文件已经下载的大小。</p>
<h4 id="知道了已经下载的大小，还有总大小。我们就可以根据这两个数值来进行断点续传了。"><a href="#知道了已经下载的大小，还有总大小。我们就可以根据这两个数值来进行断点续传了。" class="headerlink" title="知道了已经下载的大小，还有总大小。我们就可以根据这两个数值来进行断点续传了。"></a>知道了已经下载的大小，还有总大小。我们就可以根据这两个数值来进行断点续传了。</h4><h3 id="断点续传需要的请求—Range请求。"><a href="#断点续传需要的请求—Range请求。" class="headerlink" title="断点续传需要的请求—Range请求。"></a>断点续传需要的请求—Range请求。</h3><p>设置请求头信息。</p>
<p><1>格式：<br>Range格式：<br>bytes = x-y 从x位置开始下载，下载y个字节。<br>bytes = x- 从x开始  下载到完毕。<br>bytes = -x 从开始下载x个字节。</1></p>
<p><2>特点：<br>一旦Range 属性设置成功，相应的状态码就是206</2></p>
<p>//startSize 就是上文提到的dict中的NSFileSize。要把这个oc属性转化为字符串。<br>//bytes=zd - 就是从你断点的位置下载到文件结束<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  <span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%zd-"</span>,startSize];</div><div class="line">   [request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</div></pre></td></tr></table></figure></p>
<h3 id="下面讲一种NSURLSession的下载"><a href="#下面讲一种NSURLSession的下载" class="headerlink" title="下面讲一种NSURLSession的下载"></a>下面讲一种NSURLSession的下载</h3><ul>
<li><p>利用代理NSURLSessionDownloadDelegate<br>1.主要利用的代理方法。</p>
</li>
<li><p>这个是每次下载都调用的方法。和上边的一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line">      didWriteData:(int64_t)bytesWritten</div><div class="line"> totalBytesWritten:(int64_t)totalBytesWritten</div><div class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</div></pre></td></tr></table></figure>
</li>
<li><p>下载完成之后调用的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</div></pre></td></tr></table></figure>
</li>
<li><p>取消任务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData</div></pre></td></tr></table></figure>
</li>
<li><p>断点续传请求。调用上面的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * urlString = <span class="string">@"http://127.0.0.1/music.zip"</span>;</div><div class="line">    <span class="built_in">NSURL</span> * url  = [<span class="built_in">NSURL</span> URLWithString:urlString];</div></pre></td></tr></table></figure>
</li>
<li><p>创建可变请求。添加代理。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>创建下载任务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">NSURLSessionDownloadTask</span> * task = [session downloadTaskWithURL:url];</div><div class="line">    <span class="keyword">self</span>.oldSession = session;</div><div class="line">    <span class="keyword">self</span>.task = task;</div><div class="line">    [task resume];</div></pre></td></tr></table></figure>
</li>
<li><p>暂停下载</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.task cancelByProducingResumeData:^(<span class="built_in">NSData</span> * _Nullable resumeData) &#123;</div><div class="line">    <span class="keyword">self</span>.resumeData = resumeData;</div><div class="line">    </div><div class="line">&#125;];</div><div class="line">  <span class="keyword">self</span>.task = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>继续下载</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.resumeData) &#123;</div><div class="line">        <span class="keyword">self</span>.task = [<span class="keyword">self</span>.oldSession downloadTaskWithResumeData:<span class="keyword">self</span>.resumeData];</div><div class="line">        [<span class="keyword">self</span>.task resume];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于http请求]]></title>
      <url>http://yoursite.com/blog/2015/04/06/request.html</url>
      <content type="html"><![CDATA[<h4 id="网络中的请求分很多种，不过最常见的两种一种是Get请求。一种是Post请求。get请求占常用的80-，默认的http请求就是get请求。"><a href="#网络中的请求分很多种，不过最常见的两种一种是Get请求。一种是Post请求。get请求占常用的80-，默认的http请求就是get请求。" class="headerlink" title="网络中的请求分很多种，不过最常见的两种一种是Get请求。一种是Post请求。get请求占常用的80%，默认的http请求就是get请求。"></a>网络中的请求分很多种，不过最常见的两种一种是Get请求。一种是Post请求。get请求占常用的80%，默认的http请求就是get请求。</h4><h3 id="1-HTTP请求。"><a href="#1-HTTP请求。" class="headerlink" title="1.HTTP请求。"></a>1.HTTP请求。</h3><ul>
<li>一般请求采用restful 设计风格：采用相同url 不同的http 实现不同的功能。</li>
<li>利用不同请求，实现了 增/删/改/查的功能。</li>
<li>PUT       增    在服务器新增123的信息</li>
<li>DELETE 删</li>
<li>POST     改</li>
<li>GET       查</li>
<li>HEAD 获取文件的大小。</li>
<li>Range 这个可以解决断点续传。<h4 id="！一般开发中，后台将post方法-替代Put和delete"><a href="#！一般开发中，后台将post方法-替代Put和delete" class="headerlink" title="！一般开发中，后台将post方法 替代Put和delete."></a>！一般开发中，后台将post方法 替代Put和delete.</h4></li>
<li>http内部走的是socket/ (tcp/ip)。 默认情况下，tcp / ip 是一个‘长连接’。<a id="more"></a></li>
<li><p>长连接：与服务器建立连接之后，就不会自动断开。聊天/推送 心跳包。是保证持续连接的持续。</p>
</li>
<li><p>短连接：一次连接，服务器只处理一个请求。然后自动断开连接。</p>
</li>
<li>http 是一个特殊处理的tcp/ip 协议。是一个短连接。<h3 id="2-Get请求的特点："><a href="#2-Get请求的特点：" class="headerlink" title="2.Get请求的特点："></a>2.Get请求的特点：</h3></li>
<li>Get请求的参数都拼接在url后面。并且url长度是有限制的。Get请求发送参数的长度有限。不能无限延长。</li>
<li>多谢4L-（lvjsky）的提醒。（get 有字数限制 post没有。字数限制是浏览器限制，和get请求方式无关。HTTP协议规范并没有规定明确get请求的字数限制）<blockquote>
<p>各浏览器HTTP Get请求URL最大长度并不相同，几类常用浏览器最大长度及超过最大长度后提交情况如下：<br>IE6.0                :url最大长度2083个字符，超过最大长度后无法提交。<br>IE7.0                :url最大长度2083个字符，超过最大长度后仍然能提交，但是只能传过去2083个字符。<br>firefox 3.0.3     :url最大长度7764个字符，超过最大长度后无法提交。<br>Opera 9.52       :url最大长度7648个字符，超过最大长度后无法提交。<br>Google Chrome 2.0.168   :url最大长度7713个字符，超过最大长度后无法提交。</p>
</blockquote>
</li>
<li>Get请求是不安全的.参数内容暴漏在url中，对于安全性比较高的请求不能使用Get请求。</li>
<li>请求默认会在本地做数据缓存。</li>
</ul>
<h3 id="3-get请求的格式。"><a href="#3-get请求的格式。" class="headerlink" title="3.get请求的格式。"></a>3.get请求的格式。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//拼接网络请求的字符串。？后面的就是你的Get请求的内容</span></div><div class="line">    <span class="built_in">NSString</span> * string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"http://127.0.0.1/login/login.php?%@"</span>,urlstring];</div><div class="line">  </div><div class="line">    <span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:string];</div><div class="line">     <span class="comment">// 创建网络请求</span></div><div class="line">    <span class="built_in">NSURLRequest</span> * request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line">    <span class="comment">//发送请求</span></div><div class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span>*  _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        </div><div class="line">        请求回调成功 data数据就是你要的内容。</div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; !error) &#123;</div><div class="line">            </div><div class="line"> </div><div class="line">    &#125;] resume];</div></pre></td></tr></table></figure>
<h3 id="4-Post请求。"><a href="#4-Post请求。" class="headerlink" title="4.Post请求。"></a>4.Post请求。</h3><ul>
<li>post 请求的网络请求需要是一个可变请求。</li>
<li>post 请求需要设置 请求头和请求体。</li>
</ul>
<h3 id="5-Post请求的格式。"><a href="#5-Post请求的格式。" class="headerlink" title="5.Post请求的格式。"></a>5.Post请求的格式。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//  创建网络请求</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://127.0.0.1/login/login.php"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 可变请求</span></div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url cachePolicy:<span class="number">0</span> timeoutInterval:<span class="number">15</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//  设置请求方法 这里的POST可以大写也可以小写。</span></div><div class="line">    request.HTTPMethod = <span class="string">@"POST"</span>;</div><div class="line">   <span class="comment">// 这里设置请求体。请求体的格式要求是NSdata格式</span></div><div class="line">    request.HTTPBody = [<span class="string">"这里返回的是请求体。需要是NSdata格式"</span>]；</div><div class="line">    <span class="comment">// 发送请求</span></div><div class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 成功</span></div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; !error) &#123;</div><div class="line">            </div><div class="line">           </div><div class="line">    &#125;] resume];</div></pre></td></tr></table></figure>
<h3 id="6-Get请求和Post请求的区别。"><a href="#6-Get请求和Post请求的区别。" class="headerlink" title="6.Get请求和Post请求的区别。"></a>6.Get请求和Post请求的区别。</h3><ul>
<li>get  不安全 post安全</li>
<li>get 有字数限制 post没有</li>
<li>get 有缓存 post没有缓存</li>
<li>get 请求不需要设置请求头和请求体</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据传递的三种方法：通知，代理，blcok]]></title>
      <url>http://yoursite.com/blog/2015/03/08/null.html</url>
      <content type="html"><![CDATA[<h2 id="Blocks是C语言的扩充功能。用一句话来表示Blocks的扩充功能-带有自动变量-局部变量-的匿名函数。"><a href="#Blocks是C语言的扩充功能。用一句话来表示Blocks的扩充功能-带有自动变量-局部变量-的匿名函数。" class="headerlink" title="Blocks是C语言的扩充功能。用一句话来表示Blocks的扩充功能:带有自动变量(局部变量)的匿名函数。"></a>Blocks是C语言的扩充功能。用一句话来表示Blocks的扩充功能:带有自动变量(局部变量)的匿名函数。</h2><h2 id="block其实是一个代码块，block本身也可以被作为参数在方法和函数间传递，这就给予了block无限的可能。"><a href="#block其实是一个代码块，block本身也可以被作为参数在方法和函数间传递，这就给予了block无限的可能。" class="headerlink" title="block其实是一个代码块，block本身也可以被作为参数在方法和函数间传递，这就给予了block无限的可能。"></a>block其实是一个代码块，block本身也可以被作为参数在方法和函数间传递，这就给予了block无限的可能。</h2><h3 id="数据传递有三种方法-通知，代理，block"><a href="#数据传递有三种方法-通知，代理，block" class="headerlink" title="数据传递有三种方法:通知，代理，block."></a>数据传递有三种方法:通知，代理，block.</h3><p>而对于通知代理block的选择<br>1）如果数据传递两个对象没有联系。选择通知。</p>
<p>2）如果两个对象有联系的话，三个都可以。</p>
<p>3）能用代理的地方 一定也可以用block去代替。<br><a id="more"></a><br>首先说一下通知。</p>
<h4 id="通知-有三个属性。一个是通知的名称name。-通知的发布者object-一个是通知要传递的数据useInfo-可以为nil-。"><a href="#通知-有三个属性。一个是通知的名称name。-通知的发布者object-一个是通知要传递的数据useInfo-可以为nil-。" class="headerlink" title="通知 有三个属性。一个是通知的名称name。 通知的发布者object.一个是通知要传递的数据useInfo(可以为nil)。"></a>通知 有三个属性。一个是通知的名称name。 通知的发布者object.一个是通知要传递的数据useInfo(可以为nil)。</h4><p>发布通知的方法：<br>一般用 [NSNotificationCenter defaultCenter] 方法来创建通知中心通知中心(NSNotificationCenter)提供了相应的方法来帮助发布通知<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)postNotification:(<span class="built_in">NSNotification</span>*)notification;</div></pre></td></tr></table></figure></p>
<p>发布一个notification通知，可在notification对象中设置通知的名称、通知发布者、额外信息等<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSString</span>*)aName object:(<span class="keyword">id</span>)anObject;</div></pre></td></tr></table></figure></p>
<p>发布一个名称为aName的通知，anObject为这个通知的发布者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSString</span>*)aName object:(<span class="keyword">id</span>)anObject userInfo:(<span class="built_in">NSDictionary</span>*)aUserInfo;</div></pre></td></tr></table></figure></p>
<p>发布一个名称为aName的通知，anObject为这个通知的发布者，aUserInfo为额外信息</p>
<p>通知中心(NSNotificationCenter)提供了方法来注册一个监听通知的监听器(Observer)<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name (<span class="built_in">NSString</span>*)aName object:(<span class="keyword">id</span>)anObject;</div></pre></td></tr></table></figure></p>
<h4 id="observer：监听器，即谁要接收这个通知"><a href="#observer：监听器，即谁要接收这个通知" class="headerlink" title="observer：监听器，即谁要接收这个通知"></a>observer：监听器，即谁要接收这个通知</h4><h4 id="Selector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入Name：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知"><a href="#Selector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入Name：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知" class="headerlink" title="Selector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入Name：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知"></a>Selector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入Name：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知</h4><h4 id="Object：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知"><a href="#Object：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知" class="headerlink" title="Object：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知"></a>Object：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知</h4><p>第二种注册监听器的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)addObserverForName:(<span class="built_in">NSString</span>*)name object:(<span class="keyword">id</span>)obj queue:(<span class="built_in">NSOperationQueue</span>*)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span>*note))block;</div></pre></td></tr></table></figure></p>
<p>name：通知的名称</p>
<p>obj：通知发布者</p>
<p>block：收到对应的通知时，会回调这个block</p>
<p>queue：决定了block在哪个操作队列中执行，如果传nil，默认在当前操作队列中同步执行</p>
<p>取消注册通知监听器<br>通知中心不会保留(retain)监听器对象，在通知中心注册过的对象，必须在该对象释放前取消注册。否则，当相应的通知再次出现时，通知中心仍然会向该监听器发送消息。因为相应的监听器对象已经被释放了，所以可能会导致应用崩溃</p>
<p>通知中心提供了相应的方法来取消注册监听器<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="built_in">NSString</span>*)aName object:(<span class="keyword">id</span>)anObject;</div></pre></td></tr></table></figure></p>
<p>然后说一下代理。也是个人最喜欢用的。要分清被代理者和代理者。</p>
<p>被代理者 有四部分</p>
<p>1）首先定义代理（协议名称的命名规范:控件类名+Delegate）</p>
<p>2）定义代理方法。（需要传递的属性，还有把自己本身传过去）这里要注意。代理</p>
<p>3）设置属性。这里要注意代理的属性要使用weak。</p>
<p>4）在需要传递值的地方去调用代理的方法。（要判断代理方法是否可以调用）</p>
<p>在代理者需要三步。</p>
<p>1）遵守代理协议。</p>
<p>2）设置代理。</p>
<p>3实现代理方法</p>
<p>个人觉得代理比较简单。而且比较好理解。非常的规整。</p>
<p>下面说一下第三种Block</p>
<p>1）首先要在需要传递数据的类中定义一个block 属性为要传递数据的类型</p>
<p>block的属性要和NSString 一样 为copy.</p>
<p>2）在需要传递数据的地方 实现Blcok方法。首先要判断block是否可用。</p>
<p>然后把数据回调。</p>
<p>3）在需要数据的类中定义一个block 把数据接过去。</p>
<p>个人理解 block比代理要简单。</p>
<p>但是代理会看着比较清晰。让人理解。</p>
<p>所执行的步骤也都差不多。</p>
<p>只是把被代理者中的设置代理 转变成设置block接过去。然后设置一个Block去接一下回调的值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Apachi在本地配置服务器 MAC专用]]></title>
      <url>http://yoursite.com/blog/2015/03/06/Apachi.html</url>
      <content type="html"><![CDATA[<h3 id="首先要在你的磁盘里-设置一个服务器文件夹。我把他设置sites"><a href="#首先要在你的磁盘里-设置一个服务器文件夹。我把他设置sites" class="headerlink" title="首先要在你的磁盘里 设置一个服务器文件夹。我把他设置sites"></a>首先要在你的磁盘里 设置一个服务器文件夹。我把他设置sites</h3><p><img src="http://upload-images.jianshu.io/upload_images/1954780-21734f5fd3a5fbea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="切换工作目录"><a href="#切换工作目录" class="headerlink" title="切换工作目录"></a>切换工作目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$cd</span> /etc/apache2</div></pre></td></tr></table></figure>
<h3 id="用Vim编辑-httped-conf"><a href="#用Vim编辑-httped-conf" class="headerlink" title="用Vim编辑 httped.conf"></a>用Vim编辑 httped.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim httpd.conf</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-fbf414b2bf1e7e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><a id="more"></a></p>
<h3 id="然后进入这个页面"><a href="#然后进入这个页面" class="headerlink" title="然后进入这个页面"></a>然后进入这个页面</h3><p><img src="http://upload-images.jianshu.io/upload_images/1954780-62bdf1d3a2fb1e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="回车。"><a href="#回车。" class="headerlink" title="回车。"></a>回车。</h3><p><img src="http://upload-images.jianshu.io/upload_images/1954780-6b13086a05da1ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="回车默认选0。"><a href="#回车默认选0。" class="headerlink" title="回车默认选0。"></a>回车默认选0。</h3><h3 id="查找DocumentRoot-一定要注意大小写"><a href="#查找DocumentRoot-一定要注意大小写" class="headerlink" title="查找DocumentRoot  一定要注意大小写"></a>查找DocumentRoot  一定要注意大小写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/DocumentRoot</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-dc93acc9a8a0eb03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>把默认的文件夹用#注释起来。然后把你的文件夹改成默认的。<br>这里有个小技巧 用shift +v是选中这一行。 y赋值选中这一行。P是粘贴选中这一行</p>
<h3 id="修改options"><a href="#修改options" class="headerlink" title="修改options"></a>修改options</h3><p><img src="http://upload-images.jianshu.io/upload_images/1954780-074d311f01dbf481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="修改PHP"><a href="#修改PHP" class="headerlink" title="修改PHP"></a>修改PHP</h3><p><img src="http://upload-images.jianshu.io/upload_images/1954780-08955bb311c420b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>改好之后先按下esc键退出编辑模式，再输入:wq 保存并退出 如果打错了不想保存就是 :q! （如果wq不退出就wq!强制退出）</p>
<h3 id="服务器开关"><a href="#服务器开关" class="headerlink" title="服务器开关"></a>服务器开关</h3><p>服务器开关的命令就是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sudo apachectl -k start 开启</div><div class="line"></div><div class="line">sudo apachectl -k stop 关闭</div><div class="line"></div><div class="line">sudo apachectl -k restart 重新启动</div><div class="line"></div><div class="line"><span class="comment">### 另外添加一些vim命令。。</span></div><div class="line"></div><div class="line">//进入编辑模式* i               //在行首输入<span class="comment">#可以起到注释效果* #</span></div><div class="line">//进入命令模式* ESC          //选中整行* V</div><div class="line">//复制整行* y                    //在光标下方粘贴* p</div><div class="line">//将光标移动到下一行* i     //保存并退出* :wq</div><div class="line">//不保存退出!!!!!!!!!* :q!</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1954780-ad096b4d1a4941c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>成果图。~~</p>
]]></content>
    </entry>
    
  
  
</search>
